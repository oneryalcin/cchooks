{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"fasthooks","text":"<p>Delightful Claude Code hooks with a FastAPI-like developer experience.</p> <pre><code>from fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef no_rm_rf(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Typed events - Autocomplete for <code>event.command</code>, <code>event.file_path</code>, etc.</li> <li>Decorators - <code>@app.pre_tool(\"Bash\")</code>, <code>@app.on_stop()</code>, <code>@app.on_session_start()</code></li> <li>Dependency injection - <code>def handler(event, transcript: Transcript, state: State)</code></li> <li>Background tasks - Spawn async work that feeds back in subsequent hooks</li> <li>Claude sub-agents - Use Claude Agent SDK for AI-powered background tasks</li> <li>Blueprints - Compose handlers from multiple modules</li> <li>Middleware - Cross-cutting concerns like timing and logging</li> <li>Guards - <code>@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)</code></li> <li>Testing utilities - <code>MockEvent</code> and <code>TestClient</code> for easy testing</li> <li>Observability - Trace hook events with <code>FileObserver</code>, <code>SQLiteObserver</code>, or custom observers</li> <li>Visual debugger - <code>fasthooks studio</code> shows hook events inline with Claude's conversation</li> </ul>"},{"location":"#installation","title":"Installation","text":"pipuv <pre><code>pip install fasthooks\n\n# With visual debugger (studio)\npip install fasthooks[studio]\n</code></pre> <pre><code>uv add fasthooks\n\n# With visual debugger (studio)\nuv add fasthooks[studio]\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from fasthooks import HookApp, allow, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    # event.command has autocomplete!\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n    return allow()\n\n@app.pre_tool(\"Write\")\ndef check_write(event):\n    # event.file_path, event.content available\n    if event.file_path.endswith(\".env\"):\n        return deny(\"Cannot modify .env files\")\n    return allow()\n\n@app.on_stop()\ndef on_stop(event):\n    return allow()\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"#why-fasthooks","title":"Why fasthooks?","text":"<p>Claude Code hooks are powerful but the raw JSON protocol is tedious:</p> <ul> <li>No autocomplete for event fields</li> <li>Manual JSON parsing and response building</li> <li>No reusable patterns for common tasks</li> </ul> <p>fasthooks gives you a FastAPI-like experience:</p> Raw Hooks fasthooks Parse JSON from stdin Typed <code>event</code> objects Build JSON responses <code>allow()</code>, <code>deny()</code>, <code>block()</code> Manual dispatch <code>@app.pre_tool(\"Bash\")</code> Copy-paste boilerplate Blueprints &amp; middleware"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Set up your first hook in 5 minutes</li> <li>Tutorial - Learn fasthooks step by step</li> <li>Observability - Trace and debug hook events</li> <li>Studio - Visual debugger for hooks</li> <li>CLI Reference - <code>init</code>, <code>install</code>, <code>uninstall</code>, <code>status</code>, <code>studio</code> commands</li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>Low-level internals for contributors and advanced users.</p>"},{"location":"architecture/#claude-code-file-layout","title":"Claude Code File Layout","text":"<pre><code>~/.claude/\n\u251c\u2500\u2500 settings.json              # Global settings\n\u251c\u2500\u2500 settings.local.json        # Local overrides\n\u251c\u2500\u2500 CLAUDE.md                  # Global instructions\n\u251c\u2500\u2500 history.jsonl              # Command history\n\u2502\n\u251c\u2500\u2500 projects/                  # Per-project data\n\u2502   \u2514\u2500\u2500 &lt;escaped-cwd&gt;/         # e.g. -Users-john-myproject\n\u2502       \u251c\u2500\u2500 &lt;session-id&gt;.jsonl     # Main transcript\n\u2502       \u251c\u2500\u2500 agent-&lt;id&gt;.jsonl       # Subagent sidechains\n\u2502       \u2514\u2500\u2500 &lt;session-id&gt;/          # Session folder (rare)\n\u2502\n\u251c\u2500\u2500 session-env/               # Session environment data\n\u251c\u2500\u2500 file-history/              # File change history\n\u251c\u2500\u2500 plans/                     # Plan mode files\n\u2514\u2500\u2500 debug/                     # Debug logs\n</code></pre>"},{"location":"architecture/#path-escaping","title":"Path Escaping","text":"<p>Claude Code escapes the working directory path by replacing <code>/</code> with <code>-</code>:</p> <pre><code>/Users/john/myproject    \u2192  -Users-john-myproject\n/tmp/test                \u2192  -tmp-test\n/private/tmp/foo         \u2192  -private-tmp-foo\n</code></pre>"},{"location":"architecture/#transcript-files","title":"Transcript Files","text":"<p>Each session has a main transcript file: <pre><code>~/.claude/projects/-Users-john-myproject/abc123-def456.jsonl\n                   \u2514\u2500\u2500 escaped cwd \u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500 session id \u2500\u2518\n</code></pre></p> <p>Subagent sidechains (spawned via Task tool) are stored alongside: <pre><code>~/.claude/projects/-Users-john-myproject/agent-a1b2c3d.jsonl\n</code></pre></p>"},{"location":"architecture/#hook-invocation-flow","title":"Hook Invocation Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Claude Code (parent process)                                    \u2502\n\u2502                                                                 \u2502\n\u2502  1. User action triggers hook event                             \u2502\n\u2502  2. Claude Code spawns hook subprocess                          \u2502\n\u2502  3. Writes JSON to stdin:                                       \u2502\n\u2502     {                                                           \u2502\n\u2502       \"session_id\": \"abc123-...\",                               \u2502\n\u2502       \"hook_event_name\": \"PreToolUse\",                          \u2502\n\u2502       \"transcript_path\": \"~/.claude/projects/.../abc.jsonl\",    \u2502\n\u2502       \"cwd\": \"/Users/john/myproject\",                           \u2502\n\u2502       \"tool_name\": \"Bash\",                                      \u2502\n\u2502       \"tool_input\": {\"command\": \"ls -la\"}                       \u2502\n\u2502     }                                                           \u2502\n\u2502  4. Reads hook's stdout for response                            \u2502\n\u2502  5. Applies decision (allow/deny/block)                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fasthooks (hook subprocess)                                     \u2502\n\u2502                                                                 \u2502\n\u2502  app.run()                                                      \u2502\n\u2502    \u2502                                                            \u2502\n\u2502    \u251c\u2500&gt; _internal/io.py: read_stdin()                            \u2502\n\u2502    \u2502     \u2514\u2500&gt; Parse JSON from stdin                              \u2502\n\u2502    \u2502                                                            \u2502\n\u2502    \u251c\u2500&gt; _dispatch(data)                                          \u2502\n\u2502    \u2502     \u251c\u2500&gt; Route by hook_event_name                           \u2502\n\u2502    \u2502     \u251c\u2500&gt; Parse into typed Event (Bash, Write, etc.)         \u2502\n\u2502    \u2502     \u2514\u2500&gt; Find matching handlers                             \u2502\n\u2502    \u2502                                                            \u2502\n\u2502    \u251c\u2500&gt; _run_with_middleware(handlers, event)                    \u2502\n\u2502    \u2502     \u251c\u2500&gt; For each handler:                                  \u2502\n\u2502    \u2502     \u2502     \u251c\u2500&gt; _resolve_deps() \u2192 inject Transcript, State   \u2502\n\u2502    \u2502     \u2502     \u2514\u2500&gt; Call handler(event, **deps)                  \u2502\n\u2502    \u2502     \u2514\u2500&gt; Return first deny/block response                   \u2502\n\u2502    \u2502                                                            \u2502\n\u2502    \u2514\u2500&gt; _internal/io.py: write_stdout(response)                  \u2502\n\u2502          \u2514\u2500&gt; Write JSON response                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#dependency-injection","title":"Dependency Injection","text":"<p>fasthooks injects dependencies based on type hints:</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check(event, transcript: Transcript, state: State):\n    #          \u2191                 \u2191              \u2191\n    #      auto-passed     DI-injected    DI-injected\n</code></pre>"},{"location":"architecture/#how-di-works-apppy_resolve_deps","title":"How DI Works (app.py:_resolve_deps)","text":"<pre><code>def _resolve_deps(self, handler, event, cache):\n    hints = get_type_hints(handler)\n\n    for param_name, hint in hints.items():\n        if hint is Transcript:\n            # Extract path from event, create Transcript\n            transcript_path = getattr(event, \"transcript_path\", None)\n            deps[param_name] = Transcript(transcript_path)\n\n        elif hint is State:\n            # Create session-scoped State\n            deps[param_name] = State.for_session(\n                event.session_id,\n                state_dir=self.state_dir\n            )\n</code></pre>"},{"location":"architecture/#dependency-caching","title":"Dependency Caching","text":"<p>Dependencies are cached per-event to avoid redundant work:</p> <pre><code># If multiple handlers request Transcript, same instance is reused\ncache = {}\nfor handler in handlers:\n    deps = _resolve_deps(handler, event, cache)  # cache shared\n    handler(event, **deps)\n</code></pre>"},{"location":"architecture/#module-independence","title":"Module Independence","text":"<p>The transcript module is standalone - usable without hooks:</p> <pre><code>fasthooks/\n\u251c\u2500\u2500 app.py                    # HookApp - imports transcript\n\u251c\u2500\u2500 depends/\n\u2502   \u2514\u2500\u2500 transcript.py         # Re-exports for DI convenience\n\u2514\u2500\u2500 transcript/               # STANDALONE MODULE\n    \u251c\u2500\u2500 core.py               # Transcript class\n    \u251c\u2500\u2500 entries.py            # Entry types\n    \u251c\u2500\u2500 query.py              # TranscriptQuery\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"architecture/#standalone-usage","title":"Standalone Usage","text":"<pre><code># No HookApp, no events - just Transcript\nfrom fasthooks.transcript import Transcript\n\nt = Transcript(\"/path/to/transcript.jsonl\")\nt.query().assistants().with_tools().all()\nt.stats.input_tokens\n</code></pre>"},{"location":"architecture/#hook-integrated-usage","title":"Hook-Integrated Usage","text":"<pre><code># Via DI - path extracted from event automatically\nfrom fasthooks.depends import Transcript\n\n@app.pre_tool(\"Bash\")\ndef check(event, transcript: Transcript):\n    # transcript already loaded with correct session\n    pass\n</code></pre>"},{"location":"architecture/#event-routing","title":"Event Routing","text":"<pre><code>TOOL_EVENT_MAP = {\n    \"Bash\": Bash,\n    \"Write\": Write,\n    \"Read\": Read,\n    \"Edit\": Edit,\n    ...\n}\n\n# _dispatch routes by hook_event_name:\n# - PreToolUse/PostToolUse \u2192 tool handlers + catch-all (\"*\")\n# - Stop/SessionStart/etc. \u2192 lifecycle handlers\n</code></pre>"},{"location":"architecture/#handler-resolution-order","title":"Handler Resolution Order","text":"<ol> <li>Tool-specific handlers: <code>@app.pre_tool(\"Bash\")</code></li> <li>Catch-all handlers: <code>@app.pre_tool()</code> (matches all tools)</li> <li>First deny/block response wins</li> </ol>"},{"location":"architecture/#transcript-internals","title":"Transcript Internals","text":""},{"location":"architecture/#lazy-loading","title":"Lazy Loading","text":"<p>Transcript data is loaded on first access:</p> <pre><code>class Transcript:\n    def __init__(self, path):\n        self.path = Path(path) if path else None\n        self._loaded = False\n        self.entries = []\n\n    def _ensure_loaded(self):\n        if not self._loaded:\n            self.load()  # Parse JSONL file\n            self._loaded = True\n\n    @property\n    def stats(self):\n        self._ensure_loaded()  # Triggers load if needed\n        return self._stats\n</code></pre>"},{"location":"architecture/#entry-types","title":"Entry Types","text":"<pre><code>TranscriptEntry (union type)\n\u251c\u2500\u2500 UserMessage         # User input\n\u251c\u2500\u2500 AssistantMessage    # Claude response (may contain tool_use blocks)\n\u251c\u2500\u2500 SystemEntry         # System messages, summaries\n\u2514\u2500\u2500 FileHistorySnapshot # File state snapshots (not an Entry subclass)\n</code></pre>"},{"location":"architecture/#indexing","title":"Indexing","text":"<p>Transcript maintains indexes for fast lookups:</p> <pre><code>self._by_uuid: dict[str, Entry] = {}           # UUID \u2192 Entry\nself._children: dict[str, list[Entry]] = {}    # parent_uuid \u2192 children\n</code></pre>"},{"location":"architecture/#response-protocol","title":"Response Protocol","text":"<p>Hooks respond via stdout JSON:</p> <pre><code># Allow (continue execution)\n{\"decision\": \"allow\"}\n\n# Allow with message to user\n{\"decision\": \"allow\", \"hookSpecificOutput\": {\"message\": \"Approved\"}}\n\n# Deny (block this action, continue session)\n{\"decision\": \"deny\", \"reason\": \"Not allowed\"}\n\n# Block (show error to Claude, may retry)\n{\"decision\": \"block\", \"reason\": \"Rate limited\"}\n</code></pre> <p>Exit codes: - <code>0</code>: Success (response parsed) - <code>2</code>: Blocking error (stderr shown to Claude)</p>"},{"location":"architecture/#state-persistence","title":"State Persistence","text":"<p>State is session-scoped and persisted to JSON:</p> <pre><code>&lt;state_dir&gt;/&lt;session_id&gt;.json\n</code></pre> <pre><code>state = State.for_session(\"abc123\", state_dir=\"/tmp/state\")\nstate[\"count\"] = 1\nstate.save()  # Writes to /tmp/state/abc123.json\n</code></pre>"},{"location":"architecture/#background-tasks","title":"Background Tasks","text":"<p>Tasks run in separate processes, results retrieved later:</p> <pre><code>@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(analyze, event.content)  # Enqueue\n\n@app.on_prompt()\ndef check(event, tasks: Tasks):\n    if result := tasks.pop(analyze):   # Retrieve\n        return allow(message=result)\n</code></pre> <p>Backend options: - <code>InMemoryBackend</code>: Default, single-process - Custom backends for distributed execution</p>"},{"location":"architecture/#cli-architecture","title":"CLI Architecture","text":"<p>The fasthooks CLI (<code>fasthooks init</code>, <code>install</code>, <code>uninstall</code>, <code>status</code>) bridges user's Python hooks with Claude Code's JSON configuration.</p>"},{"location":"architecture/#install-flow","title":"Install Flow","text":"<pre><code>fasthooks install .claude/hooks.py\n           \u2502\n           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Validate hooks.py                                        \u2502\n\u2502    - Run in subprocess (isolated from CLI process)          \u2502\n\u2502    - Catches syntax errors, import errors                   \u2502\n\u2502    - 10-second timeout prevents hangs                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2. Introspect HookApp                                       \u2502\n\u2502    - Find `app` variable (HookApp instance)                 \u2502\n\u2502    - Extract registered handlers from internal structures   \u2502\n\u2502    - Build list: [\"PreToolUse:Bash\", \"PostToolUse:*\", ...]  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3. Generate settings.json configuration                     \u2502\n\u2502    - Build command: uv run --with fasthooks \"$CLAUDE_...\"   \u2502\n\u2502    - Group handlers by event type                           \u2502\n\u2502    - Combine matchers with | (e.g., \"Bash|Write\")           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 4. Merge with existing settings                             \u2502\n\u2502    - Read existing settings.json (supports JSONC/comments)  \u2502\n\u2502    - Remove our old entries (by command match)              \u2502\n\u2502    - Add new entries                                        \u2502\n\u2502    - Preserve other hooks (different commands)              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 5. Write lock file                                          \u2502\n\u2502    - Records: hooks_path, handlers, command, timestamp      \u2502\n\u2502    - Enables clean uninstall and status checking            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#lock-file-format","title":"Lock File Format","text":"<pre><code>{\n  \"version\": 1,\n  \"installed_at\": \"2024-01-15T10:30:00Z\",\n  \"hooks_path\": \".claude/hooks.py\",\n  \"hooks_registered\": [\"PreToolUse:Bash\", \"PostToolUse:*\", \"Stop\"],\n  \"settings_file\": \".claude/settings.json\",\n  \"command\": \"uv run --with fasthooks \\\"$CLAUDE_PROJECT_DIR/.claude/hooks.py\\\"\"\n}\n</code></pre>"},{"location":"architecture/#path-handling","title":"Path Handling","text":"<p>The CLI uses <code>$CLAUDE_PROJECT_DIR</code> for portable paths:</p> <pre><code># Generated command in settings.json\n\"uv run --with fasthooks \\\"$CLAUDE_PROJECT_DIR/.claude/hooks.py\\\"\"\n#                          \u2514\u2500\u2500 Claude Code provides this at runtime\n</code></pre> <p>This allows settings.json to be committed to git and work across machines.</p>"},{"location":"architecture/#scope-resolution","title":"Scope Resolution","text":"<pre><code>get_settings_path(scope, project_root):\n    project \u2192 project_root/.claude/settings.json\n    user    \u2192 ~/.claude/settings.json\n    local   \u2192 project_root/.claude/settings.local.json\n\nget_lock_path(scope, project_root):\n    project \u2192 project_root/.claude/.fasthooks.lock\n    user    \u2192 ~/.claude/.fasthooks.lock\n    local   \u2192 project_root/.claude/.fasthooks.local.lock\n</code></pre>"},{"location":"architecture/#introspection-safety","title":"Introspection Safety","text":"<p>User hooks.py may have side effects at import time (db connections, prints, etc.). The CLI runs introspection in a subprocess to:</p> <ol> <li>Isolate side effects from CLI process</li> <li>Catch crashes without killing CLI</li> <li>Enforce 10-second timeout</li> <li>Prevent environment pollution</li> </ol>"},{"location":"cli/","title":"CLI Reference","text":"<p>The fasthooks CLI helps you create, install, and manage Claude Code hooks.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>The CLI is included when you install fasthooks:</p> <pre><code>pip install fasthooks\n# or\nuv add fasthooks\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#fasthooks-init","title":"fasthooks init","text":"<p>Create a new hooks file with boilerplate code.</p> <pre><code>fasthooks init [--path PATH] [--force]\n</code></pre> <p>Options:</p> Option Short Default Description <code>--path</code> <code>-p</code> <code>.claude/hooks.py</code> Where to create the hooks file <code>--force</code> <code>-f</code> <code>false</code> Overwrite if file exists <p>Example:</p> <pre><code># Create default .claude/hooks.py\nfasthooks init\n\n# Create in custom location\nfasthooks init --path my-hooks.py\n\n# Overwrite existing file\nfasthooks init --force\n</code></pre> <p>Generated file:</p> <pre><code># /// script\n# requires-python = \"&gt;=3.10\"\n# dependencies = []\n# ///\n\"\"\"\nClaude Code hooks for this project.\n\nUsage:\n    fasthooks install .claude/hooks.py\n\nAfter installing, restart Claude Code for hooks to take effect.\n\"\"\"\n\nfrom fasthooks import HookApp, deny\n\napp = HookApp()\n\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    \"\"\"Example: block dangerous commands.\"\"\"\n    if \"rm -rf /\" in event.command:\n        return deny(\"Blocked dangerous command\")\n    # Return None to allow (default)\n\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"cli/#fasthooks-install","title":"fasthooks install","text":"<p>Register your hooks with Claude Code by updating <code>settings.json</code>.</p> <pre><code>fasthooks install &lt;path&gt; [--scope SCOPE] [--force]\n</code></pre> <p>Arguments:</p> Argument Required Description <code>path</code> Yes Path to your hooks.py file <p>Options:</p> Option Short Default Description <code>--scope</code> <code>-s</code> <code>project</code> Where to install: <code>project</code>, <code>user</code>, or <code>local</code> <code>--force</code> <code>-f</code> <code>false</code> Reinstall even if already installed <p>Example:</p> <pre><code># Install to project scope (recommended for teams)\nfasthooks install .claude/hooks.py\n\n# Install to user scope (personal global hooks)\nfasthooks install ~/.my-hooks/hooks.py --scope user\n\n# Install to local scope (personal, not git-tracked)\nfasthooks install .claude/hooks.py --scope local\n\n# Reinstall after modifying hooks.py\nfasthooks install .claude/hooks.py --force\n</code></pre> <p>What it does:</p> <ol> <li>Validates your hooks.py is importable (catches syntax errors)</li> <li>Discovers registered handlers (<code>@app.pre_tool</code>, <code>@app.on_stop</code>, etc.)</li> <li>Backs up existing settings.json</li> <li>Generates and merges hook configuration</li> <li>Creates a lock file to track the installation</li> </ol> <p>Output:</p> <pre><code>\u2713 Validated .claude/hooks.py\n\u2713 Found 3 handlers:\n    PreToolUse:Bash\n    PostToolUse:*\n    Stop\n\u2713 Backed up .claude/settings.json \u2192 .claude/settings.json.bak\n\u2713 Updated .claude/settings.json\n\u2713 Created .claude/.fasthooks.lock\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Restart Claude Code to activate hooks.                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Restart Required</p> <p>Claude Code does not hot-reload hooks. After installing or modifying hooks, you must restart Claude Code (exit and re-run <code>claude</code>) for changes to take effect.</p>"},{"location":"cli/#fasthooks-uninstall","title":"fasthooks uninstall","text":"<p>Remove hooks from Claude Code.</p> <pre><code>fasthooks uninstall [--scope SCOPE]\n</code></pre> <p>Options:</p> Option Short Default Description <code>--scope</code> <code>-s</code> <code>project</code> Scope to uninstall from <p>Example:</p> <pre><code># Uninstall from project scope\nfasthooks uninstall\n\n# Uninstall from user scope\nfasthooks uninstall --scope user\n</code></pre> <p>Output:</p> <pre><code>\u2713 Found installation in .claude/.fasthooks.lock\n\u2713 Backed up .claude/settings.json \u2192 .claude/settings.json.bak\n\u2713 Removed 3 hook entries\n\u2713 Deleted .claude/.fasthooks.lock\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Restart Claude Code to deactivate hooks.                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/#fasthooks-status","title":"fasthooks status","text":"<p>Show installation state and validate hooks.</p> <pre><code>fasthooks status [--scope SCOPE]\n</code></pre> <p>Options:</p> Option Short Default Description <code>--scope</code> <code>-s</code> all Check specific scope, or all if not specified <p>Example:</p> <pre><code># Check all scopes\nfasthooks status\n\n# Check only project scope\nfasthooks status --scope project\n</code></pre> <p>Output:</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Hook Status \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Project scope (.claude/settings.json)                                        \u2502\n\u2502   \u2713 Installed: .claude/hooks.py                                              \u2502\n\u2502   \u2713 Installed at: 2024-01-15 10:30:00                                        \u2502\n\u2502   \u2713 Handlers: PreToolUse:Bash, PostToolUse:*, Stop                           \u2502\n\u2502   \u2713 Hooks valid                                                              \u2502\n\u2502   \u2713 Settings in sync                                                         \u2502\n\u2502                                                                              \u2502\n\u2502 User scope (~/.claude/settings.json)                                         \u2502\n\u2502   \u2717 Not installed                                                            \u2502\n\u2502                                                                              \u2502\n\u2502 Local scope (.claude/settings.local.json)                                    \u2502\n\u2502   \u2717 Not installed                                                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Detects issues:</p> <ul> <li>Import errors in hooks.py</li> <li>Handlers added/removed since install</li> <li>Settings.json out of sync</li> <li>Multiple scopes with hooks (warns about conflicts)</li> </ul>"},{"location":"cli/#fasthooks-studio","title":"fasthooks studio","text":"<p>Launch the visual debugging UI for hooks. See exactly what your hooks receive, how they respond, and debug issues in real-time.</p> <pre><code>fasthooks studio [--db PATH] [--host HOST] [--port PORT] [--open] [--verbose]\n</code></pre> <p>Requires Extra</p> <p>Studio requires additional dependencies. Install with: <pre><code>pip install fasthooks[studio]\n</code></pre></p> <p>Options:</p> Option Default Description <code>--db</code> <code>~/.fasthooks/studio.db</code> Path to SQLite database <code>--host</code> <code>127.0.0.1</code> Host to bind server to <code>--port</code> <code>5555</code> Port to bind server to <code>--open</code> <code>false</code> Open browser automatically <code>--verbose</code> <code>false</code> Enable debug logging <p>Example:</p> <pre><code># Start studio (opens at http://localhost:5555)\nfasthooks studio\n\n# Open browser automatically\nfasthooks studio --open\n\n# Use custom port\nfasthooks studio --port 8080\n\n# Point to specific database\nfasthooks studio --db /path/to/studio.db\n</code></pre> <p>What you see:</p> <p>The studio shows a conversation view similar to Claude Code's TUI, but with hook events inline:</p> <pre><code>\ud83d\udc64 User: \"check the logs\"\n\n\ud83e\udde0 Thinking: \"Let me look at the log files...\"\n\n\ud83d\udd27 Bash(tail -f /var/log/app.log)\n   \u250c\u2500 PreToolUse hooks \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502  check_paths  \u2192 \u2705 allow   0.3ms              \u2502\n   \u2502  log_all      \u2192 \u2705 allow   0.1ms              \u2502\n   \u2502  Total: 12.5ms                                 \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\ud83d\udce5 [log output here...]\n</code></pre> <p>Setting up observability:</p> <p>For studio to capture hook events, add <code>SQLiteObserver</code> to your hooks:</p> <pre><code>from fasthooks import HookApp\nfrom fasthooks.observability import SQLiteObserver\n\napp = HookApp()\napp.add_observer(SQLiteObserver())  # Writes to ~/.fasthooks/studio.db\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    # Your handler logic\n    pass\n\napp.run()\n</code></pre> <p>See the Observability Guide for more details.</p>"},{"location":"cli/#scopes","title":"Scopes","text":"<p>fasthooks supports three installation scopes:</p> Scope Settings File Lock File Use Case <code>project</code> <code>.claude/settings.json</code> <code>.claude/.fasthooks.lock</code> Team-shared hooks (git-tracked) <code>user</code> <code>~/.claude/settings.json</code> <code>~/.claude/.fasthooks.lock</code> Personal global hooks <code>local</code> <code>.claude/settings.local.json</code> <code>.claude/.fasthooks.local.lock</code> Personal project hooks (gitignored) <p>Choosing a scope:</p> <ul> <li> <p>project (default): Best for team projects. The settings.json is committed to git, so everyone on the team gets the same hooks.</p> </li> <li> <p>user: Best for personal productivity hooks you want everywhere. Applied to all projects.</p> </li> <li> <p>local: Best for personal overrides on a specific project. Not git-tracked, won't affect teammates.</p> </li> </ul> <p>Multiple Scopes</p> <p>If hooks are installed in multiple scopes, all of them run for each event. Use <code>fasthooks status</code> to check which scopes have hooks installed.</p>"},{"location":"cli/#common-workflows","title":"Common Workflows","text":""},{"location":"cli/#setting-up-hooks-for-a-team-project","title":"Setting up hooks for a team project","text":"<pre><code># 1. Create hooks file\nfasthooks init\n\n# 2. Edit .claude/hooks.py with your handlers\n# ...\n\n# 3. Install to project scope (default)\nfasthooks install .claude/hooks.py\n\n# 4. Commit to git\ngit add .claude/hooks.py .claude/settings.json\ngit commit -m \"Add project hooks\"\n\n# 5. Restart Claude Code\n</code></pre>"},{"location":"cli/#adding-personal-global-hooks","title":"Adding personal global hooks","text":"<pre><code># 1. Create hooks file in your home directory\nmkdir -p ~/.my-hooks\nfasthooks init --path ~/.my-hooks/hooks.py\n\n# 2. Edit with your personal handlers\n# ...\n\n# 3. Install to user scope\nfasthooks install ~/.my-hooks/hooks.py --scope user\n\n# 4. Restart Claude Code\n</code></pre>"},{"location":"cli/#updating-hooks-after-changes","title":"Updating hooks after changes","text":"<pre><code># 1. Edit your hooks.py\n# ...\n\n# 2. Reinstall to update settings.json\nfasthooks install .claude/hooks.py --force\n\n# 3. Restart Claude Code\n</code></pre>"},{"location":"cli/#checking-installation-status","title":"Checking installation status","text":"<pre><code># See what's installed across all scopes\nfasthooks status\n\n# If handlers changed, resync:\nfasthooks install .claude/hooks.py --force\n</code></pre>"},{"location":"cli/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/#hooks-not-running","title":"\"Hooks not running\"","text":"<ol> <li>Did you restart Claude Code after installing?</li> <li>Run <code>fasthooks status</code> to check installation</li> <li>Verify handlers are registered: <code>fasthooks install .claude/hooks.py --force</code></li> </ol>"},{"location":"cli/#import-error-during-install","title":"\"Import error\" during install","text":"<p>Your hooks.py has a syntax error or missing dependency. Fix it and try again:</p> <pre><code># Test your hooks.py directly\npython .claude/hooks.py\n</code></pre>"},{"location":"cli/#already-installed","title":"\"Already installed\"","text":"<p>Use <code>--force</code> to reinstall:</p> <pre><code>fasthooks install .claude/hooks.py --force\n</code></pre>"},{"location":"cli/#multiple-scopes-warning","title":"\"Multiple scopes\" warning","text":"<p>You have hooks in multiple scopes. This is usually fine, but if you're seeing unexpected behavior:</p> <pre><code># Check what's installed\nfasthooks status\n\n# Uninstall from scopes you don't need\nfasthooks uninstall --scope local\n</code></pre>"},{"location":"cli/#roadmap","title":"Roadmap","text":"<p>Future CLI commands planned for v2:</p> Command Description <code>fasthooks show-config</code> Output settings.json snippet without writing (for CI/CD, debugging) <code>fasthooks test</code> Run hooks locally with mock events (quick smoke tests) <p>show-config - Preview what <code>install</code> would write: <pre><code>fasthooks show-config .claude/hooks.py\n# Outputs JSON to stdout, doesn't modify any files\n</code></pre></p> <p>test - Test handlers without Claude Code: <pre><code>fasthooks test .claude/hooks.py --event PreToolUse:Bash --input '{\"command\": \"rm -rf /\"}'\n# Output: {\"decision\": \"deny\", \"reason\": \"Dangerous command blocked\"}\n</code></pre></p> <p>Have a feature request? Open an issue.</p>"},{"location":"cli/#help","title":"Help","text":"<pre><code># Show all commands\nfasthooks --help\n\n# Show help for a specific command\nfasthooks init --help\nfasthooks install --help\nfasthooks uninstall --help\nfasthooks status --help\nfasthooks studio --help\n\n# Show version\nfasthooks --version\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Get your first Claude Code hook running in 5 minutes.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>uv (recommended) or pip</li> <li>Claude Code CLI</li> </ul>"},{"location":"getting-started/#step-1-install-fasthooks","title":"Step 1: Install fasthooks","text":"uvpip <pre><code>uv add fasthooks\n</code></pre> <pre><code>pip install fasthooks\n</code></pre> <p>Want visual debugging?</p> <p>Install with the studio extra to get <code>fasthooks studio</code>: <pre><code>pip install fasthooks[studio]\n# or\nuv add fasthooks[studio]\n</code></pre></p>"},{"location":"getting-started/#step-2-create-a-hooks-file","title":"Step 2: Create a hooks file","text":"<pre><code>fasthooks init\n</code></pre> <p>This creates <code>.claude/hooks.py</code> with example code:</p> <pre><code># /// script\n# requires-python = \"&gt;=3.10\"\n# dependencies = []\n# ///\nfrom fasthooks import HookApp, deny\n\napp = HookApp()\n\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    \"\"\"Block dangerous bash commands.\"\"\"\n    if \"rm -rf /\" in event.command:\n        return deny(\"Blocked dangerous command\")\n\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"getting-started/#step-3-customize-your-hooks","title":"Step 3: Customize your hooks","text":"<p>Edit <code>.claude/hooks.py</code> with your own handlers:</p> <pre><code>from fasthooks import HookApp, deny\n\napp = HookApp()\n\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    \"\"\"Block dangerous bash commands.\"\"\"\n    dangerous = [\"rm -rf\", \"mkfs\", \"&gt; /dev/\"]\n    if any(d in event.command for d in dangerous):\n        return deny(f\"Blocked dangerous command\")\n\n\n@app.pre_tool(\"Write\")\ndef check_write(event):\n    \"\"\"Protect sensitive files.\"\"\"\n    protected = [\".env\", \"credentials\", \"secrets\"]\n    if any(p in event.file_path for p in protected):\n        return deny(f\"Cannot modify {event.file_path}\")\n\n\n@app.on_stop()\ndef on_stop(event):\n    \"\"\"Called when Claude finishes.\"\"\"\n    pass  # Add logging, cleanup, etc.\n\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"getting-started/#step-4-install-to-claude-code","title":"Step 4: Install to Claude Code","text":"<pre><code>fasthooks install .claude/hooks.py\n</code></pre> <p>Output: <pre><code>\u2713 Validated .claude/hooks.py\n\u2713 Found 3 handlers:\n    PreToolUse:Bash\n    PreToolUse:Write\n    Stop\n\u2713 Updated .claude/settings.json\n\u2713 Created .claude/.fasthooks.lock\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Restart Claude Code to activate hooks.                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"getting-started/#step-5-restart-claude-code","title":"Step 5: Restart Claude Code","text":"<p>Important: Claude Code doesn't hot-reload hooks. You must restart it:</p> <pre><code># Exit Claude Code (Ctrl+C or type /exit)\n# Then restart\nclaude\n</code></pre> <p>Your hooks are now active!</p>"},{"location":"getting-started/#verify-its-working","title":"Verify it's working","text":"<p>Run <code>fasthooks status</code> to check:</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Hook Status \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Project scope (.claude/settings.json)                                        \u2502\n\u2502   \u2713 Installed: .claude/hooks.py                                              \u2502\n\u2502   \u2713 Handlers: PreToolUse:Bash, PreToolUse:Write, Stop                        \u2502\n\u2502   \u2713 Hooks valid                                                              \u2502\n\u2502   \u2713 Settings in sync                                                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"getting-started/#how-it-works","title":"How it works","text":"<pre><code>Claude Code \u2192 spawns hook \u2192 stdin (JSON event) \u2192 fasthooks \u2192 your handler \u2192 response \u2192 stdout \u2192 Claude Code\n</code></pre> <ol> <li>Claude Code triggers an event (e.g., about to run a bash command)</li> <li>It spawns your hooks.py as a subprocess</li> <li>Sends a JSON event to stdin</li> <li>fasthooks routes to your handler based on <code>@app.pre_tool(\"Bash\")</code></li> <li>Your handler returns <code>deny(reason)</code> or <code>None</code> (allow)</li> <li>fasthooks sends the response to stdout</li> <li>Claude Code applies the decision</li> </ol>"},{"location":"getting-started/#updating-hooks","title":"Updating hooks","text":"<p>When you modify <code>.claude/hooks.py</code>:</p> <pre><code># Reinstall to pick up new handlers\nfasthooks install .claude/hooks.py --force\n\n# Restart Claude Code\n</code></pre>"},{"location":"getting-started/#team-setup","title":"Team setup","text":"<p>For team projects, commit your hooks to git:</p> <pre><code>git add .claude/hooks.py .claude/settings.json\ngit commit -m \"Add project hooks\"\n</code></pre> <p>Teammates will get the hooks automatically when they pull.</p>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<ul> <li>Events - Learn about different event types (<code>Bash</code>, <code>Write</code>, <code>Edit</code>, etc.)</li> <li>Responses - Understand <code>allow()</code>, <code>deny()</code>, <code>block()</code></li> <li>Dependency Injection - Access <code>Transcript</code> and <code>State</code></li> <li>Observability - Trace hook events for debugging</li> <li>Studio - Visual debugger with conversation view</li> <li>CLI Reference - All CLI commands and options</li> <li>Testing - Write tests for your hooks</li> </ul>"},{"location":"observability/","title":"Observability","text":"<p>Trace what your hooks are doing. See every event, every handler, every decision.</p>"},{"location":"observability/#why-observability","title":"Why Observability?","text":"<p>Hooks run as subprocesses - you can't just add print statements and see them. Observability gives you:</p> <ul> <li>Debugging - See exactly what your hooks receive and respond</li> <li>Timing - Know which handlers are slow</li> <li>Logging - Keep a record of all hook activity</li> <li>Studio integration - Feed data to the visual debugger</li> </ul>"},{"location":"observability/#quick-start","title":"Quick Start","text":"<p>Add an observer to your app:</p> <pre><code>from fasthooks import HookApp\nfrom fasthooks.observability import FileObserver\n\napp = HookApp()\napp.add_observer(FileObserver())  # Writes to ~/.fasthooks/hooks.jsonl\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous\")\n\napp.run()\n</code></pre> <p>Now every hook event is logged:</p> <pre><code>tail -f ~/.fasthooks/hooks.jsonl\n</code></pre> <pre><code>{\"event_type\": \"hook_start\", \"hook_id\": \"abc-123\", \"tool_name\": \"Bash\", ...}\n{\"event_type\": \"handler_start\", \"handler_name\": \"check_bash\", ...}\n{\"event_type\": \"handler_end\", \"handler_name\": \"check_bash\", \"decision\": \"allow\", \"duration_ms\": 0.5, ...}\n{\"event_type\": \"hook_end\", \"hook_id\": \"abc-123\", \"duration_ms\": 12.3, ...}\n</code></pre>"},{"location":"observability/#built-in-observers","title":"Built-in Observers","text":""},{"location":"observability/#fileobserver","title":"FileObserver","text":"<p>Writes JSONL to a file. Great for debugging and log aggregation.</p> <pre><code>from fasthooks.observability import FileObserver\n\n# Default: ~/.fasthooks/hooks.jsonl\napp.add_observer(FileObserver())\n\n# Custom path\napp.add_observer(FileObserver(\"/var/log/fasthooks.jsonl\"))\n\n# Per-session files\napp.add_observer(FileObserver(\"~/.fasthooks/sessions/{session_id}.jsonl\"))\n</code></pre> <p>Features:</p> <ul> <li>Errors are swallowed (won't crash your hooks)</li> <li>Appends to existing files</li> <li>Creates directories automatically</li> <li>Supports <code>{session_id}</code> placeholder in path</li> </ul>"},{"location":"observability/#sqliteobserver","title":"SQLiteObserver","text":"<p>Writes to SQLite. Powers the studio visual debugger.</p> <pre><code>from fasthooks.observability import SQLiteObserver\n\n# Default: ~/.fasthooks/studio.db\napp.add_observer(SQLiteObserver())\n\n# Custom path\napp.add_observer(SQLiteObserver(\"/tmp/debug.db\"))\n</code></pre> <p>Features:</p> <ul> <li>Errors propagate (fail-fast for debugging)</li> <li>Indexed for fast queries</li> <li>Works with <code>fasthooks studio</code></li> </ul>"},{"location":"observability/#eventcapture","title":"EventCapture","text":"<p>Captures events in memory. Perfect for testing.</p> <pre><code>from fasthooks.observability import EventCapture\n\ncapture = EventCapture()\napp.add_observer(capture)\n\n# Run your hook...\napp.run()\n\n# Check what happened\nassert len(capture.events) == 4\nassert capture.events[0].event_type == \"hook_start\"\nassert capture.events[-1].event_type == \"hook_end\"\n</code></pre>"},{"location":"observability/#event-types","title":"Event Types","text":"<p>Every hook invocation produces these events:</p> Event Type When Fields <code>hook_start</code> Hook begins <code>hook_id</code>, <code>session_id</code>, <code>tool_name</code>, <code>hook_event_name</code> <code>handler_start</code> Handler begins <code>handler_name</code> <code>handler_end</code> Handler completes <code>handler_name</code>, <code>decision</code>, <code>duration_ms</code>, <code>reason</code> <code>handler_skip</code> Handler skipped (guard failed) <code>handler_name</code>, <code>skip_reason</code> <code>handler_error</code> Handler threw exception <code>handler_name</code>, <code>error_type</code>, <code>error_message</code> <code>hook_end</code> Hook completes <code>duration_ms</code>, <code>decision</code> <code>hook_error</code> Hook failed <code>error_type</code>, <code>error_message</code>"},{"location":"observability/#callback-style-observability","title":"Callback-Style Observability","text":"<p>For simple one-off logging, use <code>@app.on_observe</code>:</p> <pre><code>@app.on_observe(\"hook_end\")\ndef log_slow_hooks(event):\n    if event.duration_ms &gt; 100:\n        print(f\"Slow hook: {event.hook_id} took {event.duration_ms}ms\")\n\n@app.on_observe(\"handler_end\")\ndef log_denies(event):\n    if event.decision == \"deny\":\n        print(f\"Denied: {event.handler_name} - {event.reason}\")\n\n@app.on_observe()  # All events\ndef log_everything(event):\n    print(f\"{event.event_type}: {event.handler_name or event.hook_id}\")\n</code></pre>"},{"location":"observability/#building-custom-observers","title":"Building Custom Observers","text":"<p>Extend <code>BaseObserver</code> for full control:</p> <pre><code>from fasthooks.observability import BaseObserver, HookObservabilityEvent\n\nclass SlackObserver(BaseObserver):\n    \"\"\"Send denials to Slack.\"\"\"\n\n    def __init__(self, webhook_url: str):\n        self.webhook_url = webhook_url\n\n    def on_handler_end(self, event: HookObservabilityEvent) -&gt; None:\n        if event.decision == \"deny\":\n            self._send_slack(f\"Hook denied: {event.reason}\")\n\n    def _send_slack(self, message: str) -&gt; None:\n        # Your Slack webhook logic\n        pass\n\n# Use it\napp.add_observer(SlackObserver(\"https://hooks.slack.com/...\"))\n</code></pre> <p>Available hooks:</p> <pre><code>class BaseObserver:\n    def on_hook_start(self, event): ...\n    def on_hook_end(self, event): ...\n    def on_hook_error(self, event): ...\n    def on_handler_start(self, event): ...\n    def on_handler_end(self, event): ...\n    def on_handler_skip(self, event): ...\n    def on_handler_error(self, event): ...\n</code></pre>"},{"location":"observability/#hookobservabilityevent","title":"HookObservabilityEvent","text":"<p>Every observer receives <code>HookObservabilityEvent</code> objects:</p> <pre><code>@dataclass\nclass HookObservabilityEvent:\n    event_type: str          # hook_start, handler_end, etc.\n    hook_id: str             # UUID for this hook invocation\n    timestamp: datetime      # When the event occurred\n    session_id: str          # Claude session ID\n\n    # Context (may be None depending on event type)\n    hook_event_name: str | None   # PreToolUse, PostToolUse, Stop, etc.\n    tool_name: str | None         # Bash, Write, Edit, etc.\n    handler_name: str | None      # Your function name\n\n    # Timing\n    duration_ms: float | None     # Handler/hook duration\n\n    # Decision\n    decision: str | None          # allow, deny, block\n    reason: str | None            # Denial reason\n\n    # Error\n    error_type: str | None        # Exception class name\n    error_message: str | None     # Exception message\n\n    # Skip\n    skip_reason: str | None       # Why handler was skipped\n\n    # Input preview (truncated JSON of tool input)\n    input_preview: str | None\n</code></pre>"},{"location":"observability/#multiple-observers","title":"Multiple Observers","text":"<p>Add as many observers as you need:</p> <pre><code>app.add_observer(FileObserver())           # Log to file\napp.add_observer(SQLiteObserver())         # Feed studio\napp.add_observer(SlackObserver(webhook))   # Alert on denials\n</code></pre>"},{"location":"observability/#performance","title":"Performance","text":"<p>Observers run synchronously in the hook process. Keep them fast:</p> <ul> <li>FileObserver: ~1ms per event (buffered writes)</li> <li>SQLiteObserver: ~1ms per event (per-write connection)</li> <li>Custom: Avoid network calls in hot paths; batch or queue instead</li> </ul>"},{"location":"observability/#best-practices","title":"Best Practices","text":"<ol> <li>Use SQLiteObserver for debugging - It powers the studio UI</li> <li>Use FileObserver for production - Errors don't crash hooks</li> <li>Use EventCapture for testing - Assert on captured events</li> <li>Keep observers fast - Async/queue heavy work</li> <li>Filter events - Use <code>@app.on_observe(\"handler_end\")</code> not <code>@app.on_observe()</code></li> </ol>"},{"location":"observability/#next-steps","title":"Next Steps","text":"<ul> <li>Studio - Visual debugger that uses SQLiteObserver</li> <li>Testing - Use EventCapture in tests</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>Quick reference for fasthooks classes and functions.</p>"},{"location":"reference/#hookapp","title":"HookApp","text":"<p>Main application class.</p> <pre><code>from fasthooks import HookApp\n\napp = HookApp(\n    state_dir=None,       # Directory for persistent state files\n    log_dir=None,         # Directory for JSONL event logs\n    log_level=\"INFO\",     # Logging verbosity\n    task_backend=None,    # Backend for background tasks (default: InMemoryBackend)\n)\n</code></pre>"},{"location":"reference/#decorators","title":"Decorators","text":"<pre><code># Tool events\n@app.pre_tool(\"Bash\")           # Before tool executes\n@app.pre_tool(\"*\")              # All tools\n@app.post_tool(\"Write\")         # After tool executes\n@app.on_permission(\"Bash\")      # Permission dialog shown\n\n# Lifecycle events\n@app.on_stop()                  # Claude stops\n@app.on_subagent_stop()         # Subagent stops\n@app.on_session_start()         # Session starts\n@app.on_session_end()           # Session ends\n@app.on_notification()          # Notification sent\n@app.on_pre_compact()           # Before compaction\n@app.on_prompt()                # User submits prompt\n</code></pre>"},{"location":"reference/#guards","title":"Guards","text":"<pre><code>@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)\ndef check_sudo(event):\n    return deny(\"No sudo\")\n</code></pre>"},{"location":"reference/#methods","title":"Methods","text":"<pre><code>app.run()                       # Run the hook (reads stdin, writes stdout)\napp.include(blueprint)          # Include handlers from a Blueprint\n</code></pre>"},{"location":"reference/#responses","title":"Responses","text":"<pre><code>from fasthooks import allow, deny, block\n\n# Allow the action\nallow()\nallow(message=\"Warning: sensitive file\")\n\n# Deny the action (PreToolUse, PermissionRequest)\ndeny(\"Reason shown to Claude\")\ndeny(\"Reason\", interrupt=True)  # Stop Claude entirely\n\n# Block stopping (Stop, SubagentStop)\nblock(\"Reason to continue\")\n</code></pre>"},{"location":"reference/#events","title":"Events","text":""},{"location":"reference/#base-fields-all-events","title":"Base Fields (all events)","text":"<pre><code>event.session_id        # str\nevent.cwd               # str\nevent.permission_mode   # str\nevent.transcript_path   # str | None\nevent.hook_event_name   # str\n</code></pre>"},{"location":"reference/#tool-events","title":"Tool Events","text":"<pre><code>event.tool_name         # str\nevent.tool_input        # dict\nevent.tool_use_id       # str\nevent.tool_response     # dict | None (PostToolUse only)\n</code></pre>"},{"location":"reference/#typed-tool-properties","title":"Typed Tool Properties","text":"Tool Properties Bash <code>command</code>, <code>description</code>, <code>timeout</code> Write <code>file_path</code>, <code>content</code> Edit <code>file_path</code>, <code>old_string</code>, <code>new_string</code> Read <code>file_path</code>, <code>offset</code>, <code>limit</code> Grep <code>pattern</code>, <code>path</code> Glob <code>pattern</code>, <code>path</code>"},{"location":"reference/#lifecycle-events","title":"Lifecycle Events","text":"Event Properties Stop <code>stop_hook_active</code> SessionStart <code>source</code> SessionEnd <code>reason</code> PreCompact <code>trigger</code>, <code>custom_instructions</code> UserPromptSubmit <code>prompt</code> Notification <code>message</code>, <code>notification_type</code>"},{"location":"reference/#testing","title":"Testing","text":"<pre><code>from fasthooks.testing import MockEvent, TestClient\n\n# Create mock events\nMockEvent.bash(command=\"ls\")\nMockEvent.write(file_path=\"/tmp/f.txt\", content=\"...\")\nMockEvent.stop()\n\n# Test client\nclient = TestClient(app)\nresponse = client.send(MockEvent.bash(command=\"rm -rf /\"))\nassert response.decision == \"deny\"\n</code></pre>"},{"location":"reference/#dependency-injection","title":"Dependency Injection","text":"<pre><code>from fasthooks.depends import State, Transcript\nfrom fasthooks.tasks import Tasks\n\n@app.pre_tool(\"Bash\")\ndef handler(event, state: State, transcript: Transcript):\n    # state: persistent dict across hook calls\n    state[\"count\"] = state.get(\"count\", 0) + 1\n\n    # transcript: parsed conversation history\n    stats = transcript.stats\n    print(f\"Tokens: {stats.total_tokens}\")\n\n@app.pre_tool(\"Write\")\ndef with_tasks(event, tasks: Tasks):\n    # tasks: spawn background work + retrieve completed results\n    pass\n</code></pre>"},{"location":"reference/#background-tasks","title":"Background Tasks","text":""},{"location":"reference/#task-definition","title":"Task Definition","text":"<pre><code>from fasthooks.tasks import task\n\n@task\ndef simple_task(x: int) -&gt; int:\n    return x * 2\n\n@task(ttl=600, priority=5)\ndef with_options(query: str) -&gt; str:\n    return search(query)\n\n@task(transform=lambda r: r[:100])\ndef with_transform() -&gt; str:\n    return long_string()\n</code></pre>"},{"location":"reference/#tasks-recommended","title":"Tasks (recommended)","text":"<pre><code>from fasthooks.tasks import Tasks\n\n@app.pre_tool(\"Write\")\ndef handler(event, tasks: Tasks):\n    # Default key is the function name; use explicit key for concurrent calls\n    tasks.add(my_task, arg1)\n    tasks.add(other_task, data, key=\"other:1\")\n\n    # Pop by function reference (no string typos)\n    result = tasks.pop(my_task)\n</code></pre>"},{"location":"reference/#backgroundtasks","title":"BackgroundTasks","text":"<pre><code>from fasthooks.tasks import BackgroundTasks\n\n@app.pre_tool(\"Write\")\ndef handler(event, tasks: BackgroundTasks):\n    tasks.add(my_task, arg1, key=\"unique-key\")\n    tasks.add(other_task, data, key=\"other\", ttl=600)\n    tasks.cancel(\"unique-key\")\n    tasks.cancel_all()\n</code></pre>"},{"location":"reference/#pendingresults","title":"PendingResults","text":"<pre><code>from fasthooks.tasks import PendingResults\n\n@app.on_prompt()\ndef handler(event, pending: PendingResults):\n    result = pending.pop(\"key\")              # Pop completed result\n    results = pending.pop_all()              # Pop all completed\n    errors = pending.pop_errors()            # Pop failed as [(key, error), ...]\n    task_result = pending.get(\"key\")         # Get TaskResult without removing\n    has_results = pending.has(\"key\")         # Check if ready\n\n    # Async waiting\n    result = await pending.wait(\"key\", timeout=10.0)\n    results = await pending.wait_all([\"k1\", \"k2\"], timeout=30.0)\n    key, result = await pending.wait_any([\"k1\", \"k2\"])\n</code></pre>"},{"location":"reference/#taskresult","title":"TaskResult","text":"<pre><code>from fasthooks.tasks import TaskResult, TaskStatus\n\nresult: TaskResult\nresult.id           # str - Unique task ID\nresult.session_id   # str - Session that created this task\nresult.key          # str - User-provided key\nresult.status       # TaskStatus - PENDING, RUNNING, COMPLETED, FAILED, CANCELLED\nresult.value        # Any - Result value (if completed)\nresult.error        # Exception | None - Error (if failed)\nresult.is_finished  # bool - True if done (success, fail, or cancelled)\n</code></pre>"},{"location":"reference/#claude-agent-sdk-integration","title":"Claude Agent SDK Integration","text":"<p>Requires: <code>pip install fasthooks[claude]</code></p>"},{"location":"reference/#claudeagent","title":"ClaudeAgent","text":"<pre><code>from fasthooks.contrib.claude import ClaudeAgent\n\nagent = ClaudeAgent(\n    model=\"haiku\",                    # haiku, sonnet, opus\n    system_prompt=\"You are helpful.\",\n    allowed_tools=[\"Read\", \"Grep\"],\n    max_turns=5,\n    max_budget_usd=0.10,\n    cwd=\"/path/to/project\",\n)\n\n# Query Claude\nresponse = await agent.query(\"What is 2+2?\")\n\n# Override per-query\nresponse = await agent.query(\n    \"Analyze this\",\n    system_prompt=\"Override prompt\",\n    max_turns=3,\n)\n\n# As context manager\nasync with ClaudeAgent(model=\"haiku\") as agent:\n    response = await agent.query(\"Hello\")\n</code></pre>"},{"location":"reference/#agent_task-decorator","title":"@agent_task Decorator","text":"<pre><code>from fasthooks.contrib.claude import ClaudeAgent, agent_task\n\n@agent_task(\n    model=\"haiku\",\n    system_prompt=\"You review code.\",\n    allowed_tools=[\"Read\"],\n    ttl=600,\n    priority=5,\n)\nasync def review_code(agent: ClaudeAgent, code: str) -&gt; str:\n    return await agent.query(f\"Review:\\n{code}\")\n\n# Use with Tasks\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(review_code, event.content)\n</code></pre>"},{"location":"reference/#blueprint","title":"Blueprint","text":"<pre><code>from fasthooks import Blueprint\n\nsecurity = Blueprint()\n\n@security.pre_tool(\"Bash\")\ndef check(event):\n    ...\n\n# In main app\napp.include(security)\n</code></pre>"},{"location":"studio/","title":"Studio","text":"<p>Visual debugger for hooks. See exactly what your hooks receive and how they respond.</p>"},{"location":"studio/#what-is-studio","title":"What is Studio?","text":"<p>Studio shows Claude's conversation with hook events inline:</p> <pre><code>\ud83d\udc64 User: \"delete the temp files\"\n\n\ud83e\udde0 Thinking: \"I'll use rm to clean up...\"\n\n\ud83d\udd27 Bash(rm -rf /tmp/old-*)\n   \u250c\u2500 PreToolUse hooks \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502  check_dangerous  \u2192 \u2705 allow   0.8ms          \u2502\n   \u2502  log_commands     \u2192 \u2705 allow   0.2ms          \u2502\n   \u2502  Total: 15.2ms                                 \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\ud83d\udce5 Removed 3 files\n\n\ud83d\udcac Done! Cleaned up the temp files.\n</code></pre> <p>You see: - What Claude was thinking - What tool it called - Which handlers ran and what they decided - How long each handler took - The tool output</p>"},{"location":"studio/#installation","title":"Installation","text":"<pre><code>pip install fasthooks[studio]\n# or\nuv add fasthooks[studio]\n</code></pre>"},{"location":"studio/#quick-start","title":"Quick Start","text":""},{"location":"studio/#1-add-sqliteobserver-to-your-hooks","title":"1. Add SQLiteObserver to your hooks","text":"<pre><code>from fasthooks import HookApp\nfrom fasthooks.observability import SQLiteObserver\n\napp = HookApp()\napp.add_observer(SQLiteObserver())  # Writes to ~/.fasthooks/studio.db\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf /\" in event.command:\n        return deny(\"Blocked dangerous command\")\n\napp.run()\n</code></pre>"},{"location":"studio/#2-run-your-hooks-in-claude-code","title":"2. Run your hooks in Claude Code","text":"<pre><code>fasthooks install .claude/hooks.py\nclaude  # Run Claude Code with your hooks\n</code></pre>"},{"location":"studio/#3-launch-studio","title":"3. Launch Studio","text":"<pre><code>fasthooks studio --open\n</code></pre> <p>Opens http://localhost:5555 in your browser.</p>"},{"location":"studio/#studio-ui","title":"Studio UI","text":""},{"location":"studio/#session-list-sidebar","title":"Session List (Sidebar)","text":"<p>Shows all Claude sessions that have hook events:</p> <ul> <li>Session ID (truncated)</li> <li>Number of hooks fired</li> <li>Number of events captured</li> <li>Last activity time</li> </ul> <p>Click a session to view its conversation.</p>"},{"location":"studio/#conversation-view-main","title":"Conversation View (Main)","text":"<p>Shows the full conversation with hooks inline:</p> Element What it shows \ud83d\udc64 User User messages \ud83e\udde0 Thinking Claude's reasoning (collapsible) \ud83d\udd27 Tool Tool calls with inline hook events \ud83d\udce5 Output Tool results \ud83d\udcac Assistant Claude's responses"},{"location":"studio/#hook-events-panel","title":"Hook Events Panel","text":"<p>Under each tool call, you see:</p> <pre><code>\u250c\u2500 PreToolUse hooks \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  handler_name  \u2192 \u2705 allow   0.45ms            \u2502\n\u2502  another_one   \u2192 \u2705 allow   0.19ms            \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2502\n\u2502  Total: 28.1ms                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ul> <li>Handler name: Your function name</li> <li>Decision: \u2705 allow, \u274c deny, \ud83d\udeab block, \u23ed\ufe0f skip</li> <li>Duration: How long the handler took</li> <li>Reason: Why it denied (if applicable)</li> </ul> <p>Click to expand input preview (the JSON your handler received).</p>"},{"location":"studio/#real-time-updates","title":"Real-time Updates","text":"<p>Studio updates automatically when new events arrive:</p> <ul> <li>WebSocket connection to server</li> <li>\"Live\" indicator in footer</li> <li>No need to refresh</li> </ul>"},{"location":"studio/#cli-options","title":"CLI Options","text":"<pre><code>fasthooks studio [OPTIONS]\n</code></pre> Option Default Description <code>--db</code> <code>~/.fasthooks/studio.db</code> Path to SQLite database <code>--host</code> <code>127.0.0.1</code> Host to bind server to <code>--port</code> <code>5555</code> Port to bind server to <code>--open</code> <code>false</code> Open browser automatically <code>--verbose</code> <code>false</code> Enable debug logging <p>Examples:</p> <pre><code># Default (localhost:5555)\nfasthooks studio\n\n# Auto-open browser\nfasthooks studio --open\n\n# Custom port\nfasthooks studio --port 8080\n\n# Debug a specific database\nfasthooks studio --db /path/to/debug.db --verbose\n</code></pre>"},{"location":"studio/#debugging-workflows","title":"Debugging Workflows","text":""},{"location":"studio/#why-did-my-handler-deny-this","title":"\"Why did my handler deny this?\"","text":"<ol> <li>Find the tool call in the conversation</li> <li>Expand the hook events panel</li> <li>Look for \u274c deny - shows handler name and reason</li> <li>Click \"Input\" to see what the handler received</li> </ol>"},{"location":"studio/#is-my-handler-even-running","title":"\"Is my handler even running?\"","text":"<ol> <li>Check if events appear in studio</li> <li>If no events: Is SQLiteObserver added to your app?</li> <li>If events but no handler: Check your matcher (<code>@app.pre_tool(\"Bash\")</code>)</li> </ol>"},{"location":"studio/#my-handler-is-slow","title":"\"My handler is slow\"","text":"<ol> <li>Look at duration_ms for each handler</li> <li>Find the slow one</li> <li>Optimize or move heavy work to background tasks</li> </ol>"},{"location":"studio/#what-did-claude-see-after-my-deny","title":"\"What did Claude see after my deny?\"","text":"<ol> <li>Find the denied tool call</li> <li>Look at subsequent messages</li> <li>Claude typically explains why it couldn't proceed</li> </ol>"},{"location":"studio/#throwable-database","title":"Throwable Database","text":"<p>The studio database is disposable:</p> <pre><code>rm ~/.fasthooks/studio.db\n</code></pre> <p>No migrations, no schema versions. Delete it anytime - SQLiteObserver recreates it on next run.</p>"},{"location":"studio/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Your Hooks     \u2502\u2500\u2500\u2500\u2500\u25b6\u2502  SQLite DB   \u2502\u25c0\u2500\u2500\u2500\u2500\u2502  File Watcher   \u2502\n\u2502  (SQLiteObserver)     \u2502  (studio.db) \u2502     \u2502  (polls changes) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                      \u2502\n                                                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  React Frontend \u2502\u25c0\u2500\u2500\u2500\u2500\u2502  WebSocket   \u2502\u25c0\u2500\u2500\u2500\u2500\u2502  FastAPI Server \u2502\n\u2502  (browser)      \u2502     \u2502  (broadcast) \u2502     \u2502  (REST + WS)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li>Your hooks write events via SQLiteObserver</li> <li>Server polls database for changes</li> <li>Server broadcasts \"updated\" via WebSocket</li> <li>Frontend refetches data automatically</li> </ol>"},{"location":"studio/#api-endpoints","title":"API Endpoints","text":"<p>For advanced users / custom integrations:</p> Endpoint Description <code>GET /api/sessions</code> List all sessions <code>GET /api/sessions/{id}/conversation</code> Get conversation with hooks inline <code>GET /api/sessions/{id}/hooks</code> Get all hook events for session <code>GET /api/hooks/{hook_id}</code> Get single hook detail <code>GET /api/stats</code> Global statistics <code>WS /ws</code> WebSocket for real-time updates"},{"location":"studio/#troubleshooting","title":"Troubleshooting","text":""},{"location":"studio/#no-sessions-in-studio","title":"\"No sessions in studio\"","text":"<ol> <li>Did you add <code>SQLiteObserver()</code> to your hooks?</li> <li>Did you run Claude Code after adding it?</li> <li>Check the database exists: <code>ls ~/.fasthooks/studio.db</code></li> </ol>"},{"location":"studio/#events-not-updating","title":"\"Events not updating\"","text":"<ol> <li>Check \"Live\" indicator in footer</li> <li>If \"Disconnected\": refresh the page</li> <li>Check server console for errors</li> </ol>"},{"location":"studio/#cant-connect-to-studio","title":"\"Can't connect to studio\"","text":"<ol> <li>Is the server running? <code>fasthooks studio</code></li> <li>Check port isn't in use: <code>lsof -i :5555</code></li> <li>Try different port: <code>fasthooks studio --port 8080</code></li> </ol>"},{"location":"studio/#next-steps","title":"Next Steps","text":"<ul> <li>Observability - Learn about observers</li> <li>CLI Reference - All CLI commands</li> <li>Testing - Test hooks without studio</li> </ul>"},{"location":"testing/","title":"Testing Guide","text":"<p>Practical patterns for testing fasthooks. Carmack rules: simple, fast, no bloat.</p>"},{"location":"testing/#philosophy","title":"Philosophy","text":"<ul> <li>Audience: Contributors who don't know the codebase. Error messages should provide context.</li> <li>Coverage: No target. Cover what matters, ignore the number.</li> <li>Speed: Unit tests are fast (mocked I/O). Integration tests can be slower (real git, real files).</li> <li>Isolation: <code>tmp_path</code> handles cleanup. Every test gets fresh state.</li> </ul>"},{"location":"testing/#directory-structure","title":"Directory Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Common fixtures (MockEvent, tmp dirs)\n\u251c\u2500\u2500 test_app.py              # Core HookApp tests\n\u251c\u2500\u2500 test_blueprint.py        # Blueprint tests\n\u251c\u2500\u2500 test_*.py                # Other unit tests\n\u251c\u2500\u2500 strategies/\n\u2502   \u251c\u2500\u2500 conftest.py          # Strategy-specific fixtures\n\u2502   \u251c\u2500\u2500 test_base.py         # Strategy base class tests\n\u2502   \u251c\u2500\u2500 test_long_running.py # LongRunningStrategy tests\n\u2502   \u2514\u2500\u2500 test_observability.py # Observability tests\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 conftest.py          # Real git, real files fixtures\n    \u2514\u2500\u2500 test_long_running_integration.py\n</code></pre>"},{"location":"testing/#existing-patterns","title":"Existing Patterns","text":""},{"location":"testing/#mockevent-factory","title":"MockEvent Factory","text":"<p>Create typed events for testing handlers:</p> <pre><code>from fasthooks.testing import MockEvent\n\n# Tool events\nevent = MockEvent.bash(command=\"ls -la\")\nevent = MockEvent.write(file_path=\"/test.txt\", content=\"hello\")\nevent = MockEvent.edit(file_path=\"/test.txt\", old_string=\"a\", new_string=\"b\")\n\n# Lifecycle events\nevent = MockEvent.stop()\nevent = MockEvent.session_start(source=\"startup\")\nevent = MockEvent.pre_compact(trigger=\"manual\")\n\n# All events accept session_id and cwd overrides\nevent = MockEvent.bash(command=\"ls\", cwd=\"/my/project\", session_id=\"sess-123\")\n</code></pre>"},{"location":"testing/#testclient","title":"TestClient","text":"<p>Send events to a HookApp without stdin/stdout plumbing:</p> <pre><code>from fasthooks import HookApp, allow, deny\nfrom fasthooks.testing import TestClient, MockEvent\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command\")\n    return allow()\n\nclient = TestClient(app)\n\n# Returns None if allowed (no response needed)\nassert client.send(MockEvent.bash(command=\"ls\")) is None\n\n# Returns HookResponse if denied/blocked\nresponse = client.send(MockEvent.bash(command=\"rm -rf /\"))\nassert response.decision == \"deny\"\n</code></pre>"},{"location":"testing/#test-organization","title":"Test Organization","text":"<p>Use classes to group related tests:</p> <pre><code>class TestBashHandler:\n    def test_allows_safe_commands(self):\n        ...\n\n    def test_denies_dangerous_commands(self):\n        ...\n</code></pre>"},{"location":"testing/#strategy-testing-patterns","title":"Strategy Testing Patterns","text":""},{"location":"testing/#strategytestclient","title":"StrategyTestClient","text":"<p>Full-featured client for strategy testing (in <code>fasthooks.testing</code>):</p> <pre><code>from fasthooks.testing import StrategyTestClient\nfrom fasthooks.strategies import LongRunningStrategy\n\nstrategy = LongRunningStrategy(enforce_commits=True)\nclient = StrategyTestClient(strategy)\n\n# Project setup helpers\nclient.setup_project(files={\n    \"feature_list.json\": '[{\"description\": \"test\", \"passes\": false}]',\n    \"claude-progress.txt\": \"Session 1: started\",\n})\n\n# Git setup (creates real git repo in tmp_path)\nclient.setup_git()\nclient.add_uncommitted(\"dirty.py\")\n\n# Trigger hooks and get responses\nresponse = client.trigger_session_start(source=\"startup\")\nassert response.decision == \"approve\"\nassert \"1/1\" not in response.message  # 0/1 passing\n\nresponse = client.trigger_stop()\nassert response.decision == \"block\"  # uncommitted changes\n\n# Assertions\nclient.assert_blocked(\"uncommitted\")\nclient.assert_event_emitted(\"session_type\", type=\"coding\")\n</code></pre>"},{"location":"testing/#unit-tests-mocked-io","title":"Unit Tests (Mocked I/O)","text":"<p>Fast tests that mock subprocess and filesystem:</p> <pre><code># tests/strategies/test_long_running.py\nimport pytest\nfrom unittest.mock import patch, MagicMock\n\nclass TestLongRunningSessionStart:\n    \"\"\"SessionStart handler behavior.\"\"\"\n\n    @pytest.mark.parametrize(\"has_feature_list,expected_type\", [\n        (False, \"initializer\"),\n        (True, \"coding\"),\n    ])\n    def test_detects_session_type(self, strategy_client, has_feature_list, expected_type):\n        if has_feature_list:\n            strategy_client.setup_project(files={\"feature_list.json\": \"[]\"})\n\n        response = strategy_client.trigger_session_start()\n        strategy_client.assert_event_emitted(\"session_type\", type=expected_type)\n</code></pre>"},{"location":"testing/#integration-tests-real-io","title":"Integration Tests (Real I/O)","text":"<p>Slower tests with real git repos:</p> <pre><code># tests/integration/test_long_running_integration.py\n\nclass TestLongRunningRealGit:\n    \"\"\"Integration tests with real git operations.\"\"\"\n\n    def test_stop_blocked_with_uncommitted_changes(self, real_git_project):\n        \"\"\"Stop is blocked when git has uncommitted changes.\"\"\"\n        # real_git_project is a fixture that creates actual git repo\n        real_git_project.write_file(\"new.py\", \"# new file\")\n        # Don't commit - leave as uncommitted\n\n        client = StrategyTestClient(\n            LongRunningStrategy(enforce_commits=True),\n            project_dir=real_git_project.path,\n        )\n\n        response = client.trigger_stop()\n        assert response.decision == \"block\"\n        assert \"uncommitted\" in response.reason.lower()\n</code></pre>"},{"location":"testing/#observability-testing","title":"Observability Testing","text":""},{"location":"testing/#callback-collector-pattern","title":"Callback Collector Pattern","text":"<p>Capture emitted events with a simple list:</p> <pre><code>def test_observability_events_in_order(self):\n    \"\"\"Events emitted in correct order: hook_enter, decision, hook_exit.\"\"\"\n    strategy = LongRunningStrategy()\n    events = []\n\n    @strategy.on_observe\n    def collect(event):\n        events.append(event)\n\n    client = StrategyTestClient(strategy)\n    client.trigger_session_start()\n\n    # Verify order\n    event_types = [e.event_type for e in events]\n    assert event_types == [\"hook_enter\", \"decision\", \"hook_exit\"]\n\n    # Verify decision content\n    decision_event = events[1]\n    assert decision_event.decision == \"approve\"\n</code></pre>"},{"location":"testing/#testing-custom-events","title":"Testing Custom Events","text":"<pre><code>def test_custom_event_emitted(self):\n    \"\"\"Strategy emits custom session_type event.\"\"\"\n    strategy = LongRunningStrategy()\n    events = []\n\n    @strategy.on_observe\n    def collect(event):\n        if event.event_type == \"custom\":\n            events.append(event)\n\n    client = StrategyTestClient(strategy)\n    client.trigger_session_start()\n\n    assert len(events) == 1\n    assert events[0].custom_event_type == \"session_type\"\n    assert events[0].payload[\"type\"] == \"initializer\"\n</code></pre>"},{"location":"testing/#fixtures","title":"Fixtures","text":""},{"location":"testing/#root-conftestpy","title":"Root conftest.py","text":"<pre><code># tests/conftest.py\nimport pytest\nfrom pathlib import Path\nfrom fasthooks.testing import MockEvent\n\n@pytest.fixture\ndef tmp_project(tmp_path):\n    \"\"\"Empty project directory.\"\"\"\n    return tmp_path\n\n@pytest.fixture\ndef mock_event():\n    \"\"\"MockEvent factory.\"\"\"\n    return MockEvent\n</code></pre>"},{"location":"testing/#strategy-conftestpy","title":"Strategy conftest.py","text":"<pre><code># tests/strategies/conftest.py\nimport pytest\nfrom fasthooks.strategies import LongRunningStrategy\nfrom fasthooks.testing import StrategyTestClient\n\n@pytest.fixture\ndef strategy():\n    \"\"\"Default LongRunningStrategy.\"\"\"\n    return LongRunningStrategy()\n\n@pytest.fixture\ndef strategy_client(strategy, tmp_path):\n    \"\"\"StrategyTestClient with tmp project directory.\"\"\"\n    return StrategyTestClient(strategy, project_dir=tmp_path)\n</code></pre>"},{"location":"testing/#integration-conftestpy","title":"Integration conftest.py","text":"<pre><code># tests/integration/conftest.py\nimport pytest\nimport subprocess\nfrom pathlib import Path\n\nclass RealGitProject:\n    \"\"\"Helper for creating real git repos in tests.\"\"\"\n\n    def __init__(self, path: Path):\n        self.path = path\n        subprocess.run([\"git\", \"init\"], cwd=path, capture_output=True)\n        subprocess.run([\"git\", \"config\", \"user.email\", \"test@test.com\"], cwd=path)\n        subprocess.run([\"git\", \"config\", \"user.name\", \"Test\"], cwd=path)\n\n    def write_file(self, name: str, content: str):\n        (self.path / name).write_text(content)\n\n    def commit(self, message: str = \"commit\"):\n        subprocess.run([\"git\", \"add\", \".\"], cwd=self.path)\n        subprocess.run([\"git\", \"commit\", \"-m\", message], cwd=self.path)\n\n@pytest.fixture\ndef real_git_project(tmp_path):\n    \"\"\"Real git repository in tmp_path.\"\"\"\n    return RealGitProject(tmp_path)\n</code></pre>"},{"location":"testing/#error-handling-tests","title":"Error Handling Tests","text":""},{"location":"testing/#testing-fail_mode","title":"Testing fail_mode","text":"<pre><code>@pytest.mark.parametrize(\"fail_mode,expected_decision\", [\n    (\"open\", \"approve\"),    # Exception \u2192 allow (fail open)\n    (\"closed\", \"block\"),    # Exception \u2192 block (fail closed)\n])\ndef test_fail_mode_behavior(self, fail_mode, expected_decision):\n    \"\"\"Strategy respects fail_mode when handler throws.\"\"\"\n    # Create strategy with custom fail_mode\n    # Trigger handler that throws\n    # Verify decision matches expected\n</code></pre>"},{"location":"testing/#malformed-input-tests","title":"Malformed Input Tests","text":"<pre><code>def test_malformed_feature_list_logs_warning(self, strategy_client, caplog):\n    \"\"\"Invalid JSON in feature_list.json logs warning, doesn't crash.\"\"\"\n    strategy_client.setup_project(files={\n        \"feature_list.json\": \"not valid json {{{\",\n    })\n\n    response = strategy_client.trigger_session_start()\n\n    # Should still work (graceful degradation)\n    assert response.decision == \"approve\"\n    # Should log warning\n    assert \"warning\" in caplog.text.lower() or \"error\" in caplog.text.lower()\n</code></pre>"},{"location":"testing/#best-practices","title":"Best Practices","text":""},{"location":"testing/#do","title":"DO","text":"<ul> <li>Use <code>tmp_path</code> for all file operations</li> <li>Use parametrize for mode/variant testing</li> <li>Keep unit tests fast (no real subprocess/git)</li> <li>Use descriptive test names: <code>test_stop_blocked_when_uncommitted</code></li> <li>Add docstrings only for complex tests</li> </ul>"},{"location":"testing/#dont","title":"DON'T","text":"<ul> <li>Don't set coverage targets</li> <li>Don't test library internals (trust filelock, etc.)</li> <li>Don't mock what you don't own (mock your boundaries, not third-party libs)</li> <li>Don't write integration tests for every unit test case</li> </ul>"},{"location":"testing/#test-naming","title":"Test Naming","text":"<pre><code># Good: describes behavior\ndef test_stop_blocked_when_uncommitted_changes_exist(self):\n\n# Good: describes input/output\ndef test_session_start_returns_initializer_context_when_no_feature_list(self):\n\n# Bad: too vague\ndef test_stop(self):\ndef test_handler(self):\n</code></pre>"},{"location":"testing/#running-tests","title":"Running Tests","text":"<pre><code># All tests\nmake test\n\n# Unit tests only (fast)\nuv run pytest tests/ --ignore=tests/integration/\n\n# Integration tests only\nuv run pytest tests/integration/\n\n# Single test file\nuv run pytest tests/strategies/test_long_running.py -v\n\n# Single test\nuv run pytest tests/strategies/test_long_running.py::TestSessionStart::test_detects_mode -v\n\n# With coverage (informational, no target)\nuv run pytest --cov=fasthooks tests/\n</code></pre>"},{"location":"api/","title":"Python API Reference","text":"<p>Auto-generated API documentation from source code docstrings.</p>"},{"location":"api/#modules","title":"Modules","text":"Module Description HookApp Main application class Responses Response builders (<code>allow</code>, <code>deny</code>, <code>block</code>) Events Event types for tools and lifecycle Dependencies Injectable dependencies (<code>Transcript</code>, <code>State</code>) Transcript Rich transcript modeling and context engineering Tasks Background task system Claude Integration Claude Agent SDK wrapper Testing Testing utilities"},{"location":"api/#cli-utilities","title":"CLI Utilities","text":"<p>Internal modules used by the <code>fasthooks</code> CLI. These are not part of the public API but documented for contributors.</p> Module Description <code>fasthooks.cli_utils.validation</code> Hooks.py validation and introspection <code>fasthooks.cli_utils.settings</code> Settings.json read/write/merge <code>fasthooks.cli_utils.lock</code> Lock file management <code>fasthooks.cli_utils.paths</code> Project root detection, path handling <code>fasthooks.cli_utils.introspect</code> Handler extraction and config generation"},{"location":"api/#quick-links","title":"Quick Links","text":"<pre><code># Core\nfrom fasthooks import HookApp, Blueprint\nfrom fasthooks import allow, deny, block\n\n# Dependencies\nfrom fasthooks.depends import Transcript, State\n\n# Transcript (context engineering)\nfrom fasthooks.transcript import (\n    Transcript,\n    UserMessage,\n    AssistantMessage,\n    inject_tool_result,\n)\n\n# Background Tasks\nfrom fasthooks.tasks import task, Tasks\n\n# Claude Integration (optional)\nfrom fasthooks.contrib.claude import ClaudeAgent, agent_task\n\n# Testing\nfrom fasthooks.testing import MockEvent, TestClient\n</code></pre>"},{"location":"api/app/","title":"HookApp","text":"<p>The main application class for registering and running hook handlers.</p>"},{"location":"api/app/#fasthooks.app.HookApp","title":"HookApp","text":"<p>               Bases: <code>HandlerRegistry</code></p> <p>Main application for registering and running hook handlers.</p>"},{"location":"api/app/#fasthooks.app.HookApp.__init__","title":"__init__","text":"<pre><code>__init__(\n    state_dir: str | None = None,\n    log_dir: str | None = None,\n    log_level: str = \"INFO\",\n    task_backend: BaseBackend | None = None,\n)\n</code></pre> <p>Initialize HookApp.</p> <p>Parameters:</p> Name Type Description Default <code>state_dir</code> <code>str | None</code> <p>Directory for persistent state files</p> <code>None</code> <code>log_dir</code> <code>str | None</code> <p>Directory for JSONL event logs (enables built-in logging)</p> <code>None</code> <code>log_level</code> <code>str</code> <p>Logging verbosity</p> <code>'INFO'</code> <code>task_backend</code> <code>BaseBackend | None</code> <p>Backend for background tasks (default: InMemoryBackend)</p> <code>None</code>"},{"location":"api/app/#fasthooks.app.HookApp.run","title":"run","text":"<pre><code>run(\n    stdin: IO[str] | None = None,\n    stdout: IO[str] | None = None,\n) -&gt; None\n</code></pre> <p>Run the hook app, processing stdin and writing to stdout.</p> <p>Parameters:</p> Name Type Description Default <code>stdin</code> <code>IO[str] | None</code> <p>Input stream (default: sys.stdin)</p> <code>None</code> <code>stdout</code> <code>IO[str] | None</code> <p>Output stream (default: sys.stdout)</p> <code>None</code>"},{"location":"api/app/#fasthooks.app.HookApp.include","title":"include","text":"<pre><code>include(blueprint: Blueprint) -&gt; None\n</code></pre> <p>Include a blueprint's handlers.</p> <p>Parameters:</p> Name Type Description Default <code>blueprint</code> <code>Blueprint</code> <p>Blueprint to include</p> required"},{"location":"api/app/#fasthooks.app.HookApp.middleware","title":"middleware","text":"<pre><code>middleware(func: Callable[..., Any]) -&gt; Callable[..., Any]\n</code></pre> <p>Decorator to register middleware.</p> <p>Middleware wraps all handler calls and can: - Execute code before/after handlers - Short-circuit by returning a response - Modify events or responses</p> Example <p>@app.middleware def timing(event, call_next):     start = time.time()     response = call_next(event)     print(f\"Took {time.time() - start:.3f}s\")     return response</p>"},{"location":"api/app/#blueprint","title":"Blueprint","text":"<p>Composable handler groups for organizing hooks.</p>"},{"location":"api/app/#fasthooks.blueprint.Blueprint","title":"Blueprint","text":"<p>               Bases: <code>HandlerRegistry</code></p> <p>Composable collection of hook handlers.</p> <p>Use blueprints to organize handlers into logical groups that can be included in the main HookApp.</p> Example <p>security = Blueprint(\"security\")</p> <p>@security.pre_tool(\"Bash\") def no_sudo(event):     if \"sudo\" in event.command:         return deny(\"sudo not allowed\")</p> <p>app = HookApp() app.include(security)</p>"},{"location":"api/app/#fasthooks.blueprint.Blueprint.__init__","title":"__init__","text":"<pre><code>__init__(name: str)\n</code></pre> <p>Initialize Blueprint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for this blueprint (for debugging)</p> required"},{"location":"api/contrib-claude/","title":"Claude Agent SDK Integration","text":"<p>Integration with Claude Agent SDK for AI-powered background tasks.</p> <p>Optional Dependency</p> <p>Requires <code>pip install fasthooks[claude]</code></p>"},{"location":"api/contrib-claude/#claudeagent","title":"ClaudeAgent","text":""},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent","title":"ClaudeAgent  <code>dataclass</code>","text":"<p>Simplified wrapper for Claude Agent SDK.</p> <p>Provides a simple interface for querying Claude in background tasks.</p> Usage <p>agent = ClaudeAgent(model=\"haiku\", system_prompt=\"You are helpful.\")</p> Context manager usage <p>async with ClaudeAgent(model=\"sonnet\") as agent:     response = await agent.query(\"Explain this code\")</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent--simple-query","title":"Simple query","text":"<p>response = await agent.query(\"What is 2+2?\")</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent--with-tools","title":"With tools","text":"<p>agent = ClaudeAgent(allowed_tools=[\"Read\", \"Grep\"]) response = await agent.query(\"Find all TODO comments in src/\")</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model: Model | str | None = None\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.system_prompt","title":"system_prompt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>system_prompt: str | None = None\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.allowed_tools","title":"allowed_tools  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowed_tools: list[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.max_turns","title":"max_turns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_turns: int | None = None\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.max_budget_usd","title":"max_budget_usd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_budget_usd: float | None = None\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.cwd","title":"cwd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cwd: str | None = None\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.query","title":"query  <code>async</code>","text":"<pre><code>query(\n    prompt: str,\n    *,\n    system_prompt: str | None = None,\n    allowed_tools: list[str] | None = None,\n    max_turns: int | None = None,\n    max_budget_usd: float | None = None,\n    cwd: str | None = None,\n) -&gt; str\n</code></pre> <p>Query Claude and return the text response.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt to send to Claude</p> required <code>system_prompt</code> <code>str | None</code> <p>Override system prompt for this query</p> <code>None</code> <code>allowed_tools</code> <code>list[str] | None</code> <p>Override allowed tools for this query</p> <code>None</code> <code>max_turns</code> <code>int | None</code> <p>Override max turns for this query</p> <code>None</code> <code>max_budget_usd</code> <code>float | None</code> <p>Override budget limit for this query</p> <code>None</code> <code>cwd</code> <code>str | None</code> <p>Override working directory for this query</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The text response from Claude</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If claude-agent-sdk is not installed</p> <code>Exception</code> <p>If the query fails</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; ClaudeAgent\n</code></pre> <p>Enter async context.</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None\n</code></pre> <p>Exit async context.</p>"},{"location":"api/contrib-claude/#agent_task-decorator","title":"agent_task Decorator","text":""},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.agent_task","title":"agent_task","text":"<pre><code>agent_task(\n    model: Model | str = \"haiku\",\n    system_prompt: str | None = None,\n    allowed_tools: list[str] | None = None,\n    max_turns: int | None = None,\n    max_budget_usd: float | None = None,\n    *,\n    ttl: int = 300,\n    priority: int = 0,\n) -&gt; Callable[[Callable[..., Any]], Task]\n</code></pre> <p>Decorator to create a background task that uses Claude Agent.</p> <p>The decorated function receives a <code>ClaudeAgent</code> instance as its first argument, pre-configured with the specified options.</p> Usage <p>@agent_task(model=\"haiku\", system_prompt=\"You are a code reviewer.\") async def review_code(agent: ClaudeAgent, code: str) -&gt; str:     return await agent.query(f\"Review this code:\\n{code}\")</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model | str</code> <p>Claude model to use (haiku, sonnet, opus)</p> <code>'haiku'</code> <code>system_prompt</code> <code>str | None</code> <p>System prompt for the agent</p> <code>None</code> <code>allowed_tools</code> <code>list[str] | None</code> <p>Tools the agent can use</p> <code>None</code> <code>max_turns</code> <code>int | None</code> <p>Maximum conversation turns</p> <code>None</code> <code>max_budget_usd</code> <code>float | None</code> <p>Budget limit for the query</p> <code>None</code> <code>ttl</code> <code>int</code> <p>Time-to-live for task result (seconds)</p> <code>300</code> <code>priority</code> <code>int</code> <p>Task priority (higher = more important)</p> <code>0</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., Any]], Task]</code> <p>Task decorator</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.agent_task--then-use-in-a-handler","title":"Then use in a handler:","text":"<p>@app.pre_tool(\"Write\") def on_write(event, tasks: BackgroundTasks):     tasks.add(review_code, event.content, key=\"review\")</p>"},{"location":"api/contrib-claude/#type-aliases","title":"Type Aliases","text":"<pre><code># Model type hint\nModel = Literal[\"sonnet\", \"opus\", \"haiku\"]\n</code></pre>"},{"location":"api/depends/","title":"Dependencies","text":"<p>Injectable dependencies for hook handlers.</p>"},{"location":"api/depends/#transcript","title":"Transcript","text":"<p>Access to the conversation history and statistics. See Transcript API for full documentation.</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript","title":"Transcript","text":"<p>Mutable collection of entries backed by a JSONL file.</p> Usage"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript--standalone","title":"Standalone","text":"<p>transcript = Transcript(\"/path/to/transcript.jsonl\") transcript.load()</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript--query","title":"Query","text":"<p>for msg in transcript.user_messages:     print(msg.text)</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.stats","title":"stats  <code>property</code>","text":"<pre><code>stats: 'TranscriptStats'\n</code></pre> <p>Calculate transcript statistics.</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.entries","title":"entries  <code>instance-attribute</code>","text":"<pre><code>entries: list[TranscriptEntry] = []\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.user_messages","title":"user_messages  <code>property</code>","text":"<pre><code>user_messages: list[UserMessage]\n</code></pre> <p>All user messages (uses default include_archived setting).</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.assistant_messages","title":"assistant_messages  <code>property</code>","text":"<pre><code>assistant_messages: list[AssistantMessage]\n</code></pre> <p>All assistant messages (uses default include_archived setting).</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.tool_uses","title":"tool_uses  <code>property</code>","text":"<pre><code>tool_uses: list[ToolUseBlock]\n</code></pre> <p>All tool use blocks across all messages.</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.tool_results","title":"tool_results  <code>property</code>","text":"<pre><code>tool_results: list[ToolResultBlock]\n</code></pre> <p>All tool result blocks.</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: str | Path | None = None,\n    validate: Literal[\"strict\", \"warn\", \"none\"] = \"warn\",\n    safety: Literal[\"strict\", \"warn\", \"none\"] = \"warn\",\n    auto_load: bool = True,\n)\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.query","title":"query","text":"<pre><code>query(\n    include_archived: bool | None = None,\n    include_meta: bool | None = None,\n) -&gt; TranscriptQuery\n</code></pre> <p>Start a fluent query on transcript entries.</p> Returns a TranscriptQuery that supports chaining <p>transcript.query().filter(type=\"assistant\").first() transcript.query().assistants().with_tools().count()</p> <p>Parameters:</p> Name Type Description Default <code>include_archived</code> <code>bool | None</code> <p>Include archived entries. Defaults to self.include_archived.</p> <code>None</code> <code>include_meta</code> <code>bool | None</code> <p>Include meta entries. Defaults to self.include_meta.</p> <code>None</code> <p>Returns:</p> Type Description <code>TranscriptQuery</code> <p>TranscriptQuery for fluent chaining</p>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats","title":"TranscriptStats","text":"<p>Statistics extracted from a transcript.</p>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.input_tokens","title":"input_tokens  <code>instance-attribute</code>","text":"<pre><code>input_tokens = input_tokens\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.output_tokens","title":"output_tokens  <code>instance-attribute</code>","text":"<pre><code>output_tokens = output_tokens\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.cache_read_tokens","title":"cache_read_tokens  <code>instance-attribute</code>","text":"<pre><code>cache_read_tokens = cache_read_tokens\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.cache_creation_tokens","title":"cache_creation_tokens  <code>instance-attribute</code>","text":"<pre><code>cache_creation_tokens = cache_creation_tokens\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.tool_calls","title":"tool_calls  <code>instance-attribute</code>","text":"<pre><code>tool_calls = tool_calls or {}\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.error_count","title":"error_count  <code>instance-attribute</code>","text":"<pre><code>error_count = error_count\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.message_count","title":"message_count  <code>instance-attribute</code>","text":"<pre><code>message_count = message_count\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.turn_count","title":"turn_count  <code>instance-attribute</code>","text":"<pre><code>turn_count = turn_count\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.compact_count","title":"compact_count  <code>instance-attribute</code>","text":"<pre><code>compact_count = compact_count\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.duration_seconds","title":"duration_seconds  <code>instance-attribute</code>","text":"<pre><code>duration_seconds = duration_seconds\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.slug","title":"slug  <code>instance-attribute</code>","text":"<pre><code>slug = slug\n</code></pre>"},{"location":"api/depends/#state","title":"State","text":"<p>Persistent session-scoped storage.</p>"},{"location":"api/depends/#fasthooks.depends.state.State","title":"State","text":"<p>               Bases: <code>dict[str, Any]</code></p> <p>Persistent dict backed by JSON file.</p> <p>Behaves like a regular dict but can save/load from file. Use as context manager for auto-save on exit.</p>"},{"location":"api/depends/#fasthooks.depends.state.State.for_session","title":"for_session  <code>classmethod</code>","text":"<pre><code>for_session(\n    session_id: str, state_dir: Path | str\n) -&gt; State\n</code></pre> <p>Create state scoped to a session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>state_dir</code> <code>Path | str</code> <p>Directory for state files</p> required <p>Returns:</p> Type Description <code>State</code> <p>State instance for this session</p>"},{"location":"api/depends/#fasthooks.depends.state.State.save","title":"save","text":"<pre><code>save() -&gt; None\n</code></pre> <p>Save state to file.</p>"},{"location":"api/events/","title":"Events","text":"<p>Event types for tools and lifecycle hooks.</p>"},{"location":"api/events/#base-event","title":"Base Event","text":""},{"location":"api/events/#fasthooks.events.base.BaseEvent","title":"BaseEvent","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for all Claude Code hook events.</p> <p>All events share these common fields from the hook input.</p>"},{"location":"api/events/#fasthooks.events.base.BaseEvent.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.base.BaseEvent.cwd","title":"cwd  <code>instance-attribute</code>","text":"<pre><code>cwd: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.base.BaseEvent.permission_mode","title":"permission_mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>permission_mode: str | None = None\n</code></pre>"},{"location":"api/events/#fasthooks.events.base.BaseEvent.transcript_path","title":"transcript_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transcript_path: str | None = None\n</code></pre>"},{"location":"api/events/#fasthooks.events.base.BaseEvent.hook_event_name","title":"hook_event_name  <code>instance-attribute</code>","text":"<pre><code>hook_event_name: str\n</code></pre>"},{"location":"api/events/#tool-events","title":"Tool Events","text":""},{"location":"api/events/#fasthooks.events.tools.ToolEvent","title":"ToolEvent","text":"<p>               Bases: <code>BaseEvent</code></p> <p>Base class for tool-related events (PreToolUse, PostToolUse).</p>"},{"location":"api/events/#fasthooks.events.tools.ToolEvent.tool_name","title":"tool_name  <code>instance-attribute</code>","text":"<pre><code>tool_name: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.tools.ToolEvent.tool_input","title":"tool_input  <code>instance-attribute</code>","text":"<pre><code>tool_input: dict[str, Any]\n</code></pre>"},{"location":"api/events/#fasthooks.events.tools.ToolEvent.tool_use_id","title":"tool_use_id  <code>instance-attribute</code>","text":"<pre><code>tool_use_id: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.tools.ToolEvent.tool_response","title":"tool_response  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tool_response: dict[str, Any] | None = None\n</code></pre>"},{"location":"api/events/#fasthooks.events.tools.Bash","title":"Bash","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Bash tool event with typed accessors.</p>"},{"location":"api/events/#fasthooks.events.tools.Bash.command","title":"command  <code>property</code>","text":"<pre><code>command: str\n</code></pre> <p>The bash command to execute.</p>"},{"location":"api/events/#fasthooks.events.tools.Bash.description","title":"description  <code>property</code>","text":"<pre><code>description: str | None\n</code></pre> <p>Optional description of the command.</p>"},{"location":"api/events/#fasthooks.events.tools.Bash.timeout","title":"timeout  <code>property</code>","text":"<pre><code>timeout: int | None\n</code></pre> <p>Optional timeout in milliseconds.</p>"},{"location":"api/events/#fasthooks.events.tools.Write","title":"Write","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Write tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Write.file_path","title":"file_path  <code>property</code>","text":"<pre><code>file_path: str\n</code></pre> <p>Path to file being written.</p>"},{"location":"api/events/#fasthooks.events.tools.Write.content","title":"content  <code>property</code>","text":"<pre><code>content: str\n</code></pre> <p>Content to write.</p>"},{"location":"api/events/#fasthooks.events.tools.Edit","title":"Edit","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Edit tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Edit.file_path","title":"file_path  <code>property</code>","text":"<pre><code>file_path: str\n</code></pre> <p>Path to file being edited.</p>"},{"location":"api/events/#fasthooks.events.tools.Edit.old_string","title":"old_string  <code>property</code>","text":"<pre><code>old_string: str\n</code></pre> <p>String to replace.</p>"},{"location":"api/events/#fasthooks.events.tools.Edit.new_string","title":"new_string  <code>property</code>","text":"<pre><code>new_string: str\n</code></pre> <p>Replacement string.</p>"},{"location":"api/events/#fasthooks.events.tools.Read","title":"Read","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Read tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Read.file_path","title":"file_path  <code>property</code>","text":"<pre><code>file_path: str\n</code></pre> <p>Path to file being read.</p>"},{"location":"api/events/#fasthooks.events.tools.Read.offset","title":"offset  <code>property</code>","text":"<pre><code>offset: int | None\n</code></pre> <p>Optional line offset.</p>"},{"location":"api/events/#fasthooks.events.tools.Read.limit","title":"limit  <code>property</code>","text":"<pre><code>limit: int | None\n</code></pre> <p>Optional line limit.</p>"},{"location":"api/events/#fasthooks.events.tools.Grep","title":"Grep","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Grep tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Grep.pattern","title":"pattern  <code>property</code>","text":"<pre><code>pattern: str\n</code></pre> <p>Search pattern.</p>"},{"location":"api/events/#fasthooks.events.tools.Grep.path","title":"path  <code>property</code>","text":"<pre><code>path: str | None\n</code></pre> <p>Path to search in.</p>"},{"location":"api/events/#fasthooks.events.tools.Glob","title":"Glob","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Glob tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Glob.pattern","title":"pattern  <code>property</code>","text":"<pre><code>pattern: str\n</code></pre> <p>Glob pattern.</p>"},{"location":"api/events/#fasthooks.events.tools.Glob.path","title":"path  <code>property</code>","text":"<pre><code>path: str | None\n</code></pre> <p>Base path.</p>"},{"location":"api/events/#fasthooks.events.tools.Task","title":"Task","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Task (subagent) tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Task.prompt","title":"prompt  <code>property</code>","text":"<pre><code>prompt: str\n</code></pre> <p>Task prompt.</p>"},{"location":"api/events/#fasthooks.events.tools.Task.description","title":"description  <code>property</code>","text":"<pre><code>description: str\n</code></pre> <p>Task description.</p>"},{"location":"api/events/#fasthooks.events.tools.WebSearch","title":"WebSearch","text":"<p>               Bases: <code>ToolEvent</code></p> <p>WebSearch tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.WebSearch.query","title":"query  <code>property</code>","text":"<pre><code>query: str\n</code></pre> <p>Search query.</p>"},{"location":"api/events/#fasthooks.events.tools.WebFetch","title":"WebFetch","text":"<p>               Bases: <code>ToolEvent</code></p> <p>WebFetch tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.WebFetch.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>URL to fetch.</p>"},{"location":"api/events/#fasthooks.events.tools.WebFetch.prompt","title":"prompt  <code>property</code>","text":"<pre><code>prompt: str\n</code></pre> <p>Prompt for processing.</p>"},{"location":"api/events/#lifecycle-events","title":"Lifecycle Events","text":""},{"location":"api/events/#fasthooks.events.lifecycle.Stop","title":"Stop","text":"<p>               Bases: <code>BaseEvent</code></p> <p>Stop event - main agent finished responding.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.Stop.stop_hook_active","title":"stop_hook_active  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_hook_active: bool = False\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.SubagentStop","title":"SubagentStop","text":"<p>               Bases: <code>BaseEvent</code></p> <p>SubagentStop event - subagent finished responding.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.SubagentStop.stop_hook_active","title":"stop_hook_active  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_hook_active: bool = False\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.SessionStart","title":"SessionStart","text":"<p>               Bases: <code>BaseEvent</code></p> <p>SessionStart event - session begins or resumes.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.SessionStart.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.SessionEnd","title":"SessionEnd","text":"<p>               Bases: <code>BaseEvent</code></p> <p>SessionEnd event - session ends.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.SessionEnd.reason","title":"reason  <code>instance-attribute</code>","text":"<pre><code>reason: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.PreCompact","title":"PreCompact","text":"<p>               Bases: <code>BaseEvent</code></p> <p>PreCompact event - before context compaction.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.PreCompact.trigger","title":"trigger  <code>instance-attribute</code>","text":"<pre><code>trigger: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.PreCompact.custom_instructions","title":"custom_instructions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_instructions: str | None = None\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.UserPromptSubmit","title":"UserPromptSubmit","text":"<p>               Bases: <code>BaseEvent</code></p> <p>UserPromptSubmit event - user submits a prompt.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.UserPromptSubmit.prompt","title":"prompt  <code>instance-attribute</code>","text":"<pre><code>prompt: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.Notification","title":"Notification","text":"<p>               Bases: <code>BaseEvent</code></p> <p>Notification event - notification sent.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.Notification.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.Notification.notification_type","title":"notification_type  <code>instance-attribute</code>","text":"<pre><code>notification_type: str\n</code></pre>"},{"location":"api/responses/","title":"Responses","text":"<p>Response builders for hook handlers.</p>"},{"location":"api/responses/#response-functions","title":"Response Functions","text":""},{"location":"api/responses/#fasthooks.responses.allow","title":"allow","text":"<pre><code>allow(\n    *,\n    modify: dict[str, Any] | None = None,\n    message: str | None = None,\n) -&gt; HookResponse\n</code></pre> <p>Allow the action to proceed.</p> <p>Parameters:</p> Name Type Description Default <code>modify</code> <code>dict[str, Any] | None</code> <p>Optional dict to modify tool input before execution</p> <code>None</code> <code>message</code> <code>str | None</code> <p>Optional message shown to user</p> <code>None</code> <p>Returns:</p> Type Description <code>HookResponse</code> <p>HookResponse with approve decision</p>"},{"location":"api/responses/#fasthooks.responses.deny","title":"deny","text":"<pre><code>deny(\n    reason: str, *, interrupt: bool = False\n) -&gt; HookResponse\n</code></pre> <p>Deny/block the action.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>Explanation shown to Claude</p> required <code>interrupt</code> <code>bool</code> <p>If True, stops Claude entirely</p> <code>False</code> <p>Returns:</p> Type Description <code>HookResponse</code> <p>HookResponse with deny decision</p>"},{"location":"api/responses/#fasthooks.responses.block","title":"block","text":"<pre><code>block(reason: str) -&gt; HookResponse\n</code></pre> <p>Block Stop/SubagentStop - force Claude to continue.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>Explanation of what Claude should do</p> required <p>Returns:</p> Type Description <code>HookResponse</code> <p>HookResponse with block decision</p>"},{"location":"api/responses/#fasthooks.responses.approve_permission","title":"approve_permission","text":"<pre><code>approve_permission(\n    *, modify: dict[str, Any] | None = None\n) -&gt; PermissionHookResponse\n</code></pre> <p>Approve a permission request.</p> <p>Parameters:</p> Name Type Description Default <code>modify</code> <code>dict[str, Any] | None</code> <p>Optional dict to modify tool input before execution</p> <code>None</code> <p>Returns:</p> Type Description <code>PermissionHookResponse</code> <p>PermissionHookResponse with allow behavior</p>"},{"location":"api/responses/#fasthooks.responses.deny_permission","title":"deny_permission","text":"<pre><code>deny_permission(\n    message: str | None = None, *, interrupt: bool = False\n) -&gt; PermissionHookResponse\n</code></pre> <p>Deny a permission request.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>Explanation shown to Claude</p> <code>None</code> <code>interrupt</code> <code>bool</code> <p>If True, stops Claude entirely</p> <code>False</code> <p>Returns:</p> Type Description <code>PermissionHookResponse</code> <p>PermissionHookResponse with deny behavior</p>"},{"location":"api/responses/#response-classes","title":"Response Classes","text":""},{"location":"api/responses/#fasthooks.responses.BaseHookResponse","title":"BaseHookResponse","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for hook responses.</p>"},{"location":"api/responses/#fasthooks.responses.BaseHookResponse.should_return","title":"should_return","text":"<pre><code>should_return() -&gt; bool\n</code></pre> <p>Whether this response should be returned (stop handler chain).</p> <p>Override in subclasses for custom behavior. Default: always return.</p>"},{"location":"api/responses/#fasthooks.responses.BaseHookResponse.to_json","title":"to_json  <code>abstractmethod</code>","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Serialize to Claude Code expected JSON format.</p>"},{"location":"api/responses/#fasthooks.responses.HookResponse","title":"HookResponse  <code>dataclass</code>","text":"<p>               Bases: <code>BaseHookResponse</code></p> <p>Response from a hook handler.</p>"},{"location":"api/responses/#fasthooks.responses.HookResponse.decision","title":"decision  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>decision: str | None = None\n</code></pre>"},{"location":"api/responses/#fasthooks.responses.HookResponse.reason","title":"reason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reason: str | None = None\n</code></pre>"},{"location":"api/responses/#fasthooks.responses.HookResponse.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str | None = None\n</code></pre>"},{"location":"api/responses/#fasthooks.responses.HookResponse.interrupt","title":"interrupt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interrupt: bool = False\n</code></pre>"},{"location":"api/responses/#fasthooks.responses.HookResponse.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Serialize to Claude Code expected JSON format.</p>"},{"location":"api/tasks/","title":"Background Tasks","text":"<p>Background task system for async operations in hooks.</p>"},{"location":"api/tasks/#task-definition","title":"Task Definition","text":""},{"location":"api/tasks/#fasthooks.tasks.base.task","title":"task","text":"<pre><code>task(\n    func: Callable[..., Any] | None = None,\n    *,\n    priority: int = 0,\n    ttl: int = 300,\n    transform: Callable[[Any], Any] | None = None,\n) -&gt; Task | Callable[[Callable[..., Any]], Task]\n</code></pre> <p>Decorator to define a background task.</p> Usage <p>@task def simple_task(x: int) -&gt; int:     return x * 2</p> <p>@task(priority=2, ttl=600) def slow_task(query: str) -&gt; str:     return search_db(query)</p> <p>@task(transform=lambda r: f\"Result: {r}\") def formatted_task(x: int) -&gt; str:     return x * 2</p>"},{"location":"api/tasks/#fasthooks.tasks.base.Task","title":"Task  <code>dataclass</code>","text":"<p>A background task definition.</p> Usage <p>@task def my_task(x: int) -&gt; int:     return x * 2</p>"},{"location":"api/tasks/#fasthooks.tasks.base.Task--or-with-options","title":"Or with options","text":"<p>@task(priority=2, ttl=600) def slow_task(query: str) -&gt; str:     return search_db(query)</p>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.func","title":"func  <code>instance-attribute</code>","text":"<pre><code>func: Callable[..., Any]\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.ttl","title":"ttl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ttl: int = 300\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.transform","title":"transform  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transform: Callable[[Any], Any] | None = None\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get task function name.</p>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.__call__","title":"__call__","text":"<pre><code>__call__(*args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Call the underlying function directly (for testing).</p>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult","title":"TaskResult  <code>dataclass</code>","text":"<p>Result of a background task execution.</p>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.key","title":"key  <code>instance-attribute</code>","text":"<pre><code>key: str\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: TaskStatus = PENDING\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: Any = None\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.error","title":"error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>error: Exception | None = None\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.created_at","title":"created_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created_at: float = field(default_factory=time)\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.started_at","title":"started_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>started_at: float | None = None\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.finished_at","title":"finished_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>finished_at: float | None = None\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.ttl","title":"ttl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ttl: int = 300\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.is_finished","title":"is_finished  <code>property</code>","text":"<pre><code>is_finished: bool\n</code></pre> <p>Check if task has completed (success or failure).</p>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.is_expired","title":"is_expired  <code>property</code>","text":"<pre><code>is_expired: bool\n</code></pre> <p>Check if task result has expired based on TTL.</p> <p>TTL is measured from finished_at (completion time) if available, otherwise from created_at. This ensures results remain available for the full TTL after completion, even for long-running tasks.</p>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus","title":"TaskStatus","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Status of a background task.</p>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus.PENDING","title":"PENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PENDING = 'pending'\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus.RUNNING","title":"RUNNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RUNNING = 'running'\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus.COMPLETED","title":"COMPLETED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COMPLETED = 'completed'\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus.FAILED","title":"FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAILED = 'failed'\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus.CANCELLED","title":"CANCELLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELLED = 'cancelled'\n</code></pre>"},{"location":"api/tasks/#dependencies","title":"Dependencies","text":""},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks","title":"Tasks","text":"<p>Unified background tasks dependency (enqueue + results).</p> <p>Injected into handlers to both enqueue background tasks and access results from previous hook calls.</p> <p>All operations are non-blocking: - <code>add()</code> submits to thread pool and returns immediately - <code>pop()</code>/<code>get()</code>/<code>has()</code> are dict lookups, return instantly - <code>wait*()</code> methods are async and yield while polling</p> <p>Keys are optional. If omitted, the task key defaults to the function name. For multiple concurrent calls to the same function, provide an explicit key to avoid collisions (later enqueues overwrite earlier results for the same key).</p> Usage <p>@app.on_prompt() def handler(event, tasks: Tasks):     if result := tasks.pop(memory_lookup):         return allow(message=f\"Found: {result}\")</p> <pre><code>tasks.add(memory_lookup, event.prompt)\nreturn allow()\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.__init__","title":"__init__","text":"<pre><code>__init__(backend: BaseBackend, session_id: str)\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.add","title":"add","text":"<pre><code>add(\n    func: Callable[..., Any] | Task,\n    *args: Any,\n    key: str | None = None,\n    ttl: int = 300,\n    **kwargs: Any,\n) -&gt; TaskResult\n</code></pre> <p>Add a task to be executed in the background.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | Task</code> <p>The function or Task to execute</p> required <code>*args</code> <code>Any</code> <p>Positional arguments for the function</p> <code>()</code> <code>key</code> <code>str | None</code> <p>Optional unique key (defaults to function name)</p> <code>None</code> <code>ttl</code> <code>int</code> <p>Time-to-live in seconds for the result (default 300)</p> <code>300</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>TaskResult</code> <p>TaskResult with status 'pending'</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.cancel","title":"cancel","text":"<pre><code>cancel(key: str | Callable[..., Any] | Task) -&gt; bool\n</code></pre> <p>Cancel a pending/running task by key.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.cancel_all","title":"cancel_all","text":"<pre><code>cancel_all() -&gt; int\n</code></pre> <p>Cancel all tasks for this session. Returns count cancelled.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.get","title":"get","text":"<pre><code>get(\n    key: str | Callable[..., Any] | Task,\n) -&gt; TaskResult | None\n</code></pre> <p>Get a task result without removing it.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.pop","title":"pop","text":"<pre><code>pop(key: str | Callable[..., Any] | Task) -&gt; Any | None\n</code></pre> <p>Pop a completed result value, removing it from storage.</p> <p>Returns None if task not found or not yet completed.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.pop_all","title":"pop_all","text":"<pre><code>pop_all() -&gt; list[Any]\n</code></pre> <p>Pop all completed results for this session.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.pop_errors","title":"pop_errors","text":"<pre><code>pop_errors() -&gt; list[tuple[str, Exception]]\n</code></pre> <p>Pop all failed results, returning (key, error) pairs.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.has","title":"has","text":"<pre><code>has(\n    key: str | Callable[..., Any] | Task | None = None,\n) -&gt; bool\n</code></pre> <p>Check if there are completed results.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | Callable[..., Any] | Task | None</code> <p>Specific task key to check, or None to check any</p> <code>None</code>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.wait","title":"wait  <code>async</code>","text":"<pre><code>wait(\n    key: str | Callable[..., Any] | Task,\n    timeout: float = 30.0,\n) -&gt; Any | None\n</code></pre> <p>Wait for a specific task to complete.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.wait_all","title":"wait_all  <code>async</code>","text":"<pre><code>wait_all(\n    keys: list[str | Callable[..., Any] | Task],\n    timeout: float = 30.0,\n) -&gt; dict[str, Any]\n</code></pre> <p>Wait for multiple tasks to complete. Returns dict of key -&gt; value.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.wait_any","title":"wait_any  <code>async</code>","text":"<pre><code>wait_any(\n    keys: list[str | Callable[..., Any] | Task],\n    timeout: float = 30.0,\n) -&gt; tuple[str, Any] | None\n</code></pre> <p>Wait for any task to complete. Returns (key, value) or None.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.BackgroundTasks","title":"BackgroundTasks","text":"<p>FastAPI-style task enqueueing dependency.</p> <p>Injected into handlers to allow adding background tasks.</p> Usage <p>@app.pre_tool(\"Write\") def on_write(event, tasks: BackgroundTasks):     tasks.add(review_code, event.content, key=\"review\")     return allow()</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.BackgroundTasks.__init__","title":"__init__","text":"<pre><code>__init__(backend: BaseBackend, session_id: str)\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.depends.BackgroundTasks.add","title":"add","text":"<pre><code>add(\n    func: Callable[..., Any] | Task,\n    *args: Any,\n    key: str,\n    ttl: int = 300,\n    **kwargs: Any,\n) -&gt; TaskResult\n</code></pre> <p>Add a task to be executed in the background.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | Task</code> <p>The function or Task to execute</p> required <code>*args</code> <code>Any</code> <p>Positional arguments for the function</p> <code>()</code> <code>key</code> <code>str</code> <p>Unique key for this task (used to retrieve results)</p> required <code>ttl</code> <code>int</code> <p>Time-to-live in seconds for the result (default 300)</p> <code>300</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>TaskResult</code> <p>TaskResult with status 'pending'</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.BackgroundTasks.cancel","title":"cancel","text":"<pre><code>cancel(key: str) -&gt; bool\n</code></pre> <p>Cancel a pending/running task by key.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.BackgroundTasks.cancel_all","title":"cancel_all","text":"<pre><code>cancel_all() -&gt; int\n</code></pre> <p>Cancel all tasks for this session. Returns count cancelled.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults","title":"PendingResults","text":"<p>Access to completed background task results.</p> <p>Injected into handlers to retrieve results from previous tasks.</p> Usage <p>@app.on_prompt() def check_memory(event, pending: PendingResults):     if result := pending.pop(\"memory\"):         return allow(message=f\"Found: {result}\")     return allow()</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.__init__","title":"__init__","text":"<pre><code>__init__(backend: BaseBackend, session_id: str)\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.get","title":"get","text":"<pre><code>get(key: str) -&gt; TaskResult | None\n</code></pre> <p>Get a task result without removing it.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.pop","title":"pop","text":"<pre><code>pop(key: str) -&gt; Any | None\n</code></pre> <p>Pop a completed result value, removing it from storage.</p> <p>Returns None if task not found or not yet completed.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.pop_all","title":"pop_all","text":"<pre><code>pop_all() -&gt; list[Any]\n</code></pre> <p>Pop all completed results for this session.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.pop_errors","title":"pop_errors","text":"<pre><code>pop_errors() -&gt; list[tuple[str, Exception]]\n</code></pre> <p>Pop all failed results, returning (key, error) pairs.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.has","title":"has","text":"<pre><code>has(key: str | None = None) -&gt; bool\n</code></pre> <p>Check if there are completed results.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | None</code> <p>Specific task key to check, or None to check any</p> <code>None</code>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.wait","title":"wait  <code>async</code>","text":"<pre><code>wait(key: str, timeout: float = 30.0) -&gt; Any | None\n</code></pre> <p>Wait for a specific task to complete.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Task key to wait for</p> required <code>timeout</code> <code>float</code> <p>Maximum seconds to wait</p> <code>30.0</code> <p>Returns:</p> Type Description <code>Any | None</code> <p>Task result value, or None if timeout/failed/cancelled</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.wait_all","title":"wait_all  <code>async</code>","text":"<pre><code>wait_all(\n    keys: list[str], timeout: float = 30.0\n) -&gt; dict[str, Any]\n</code></pre> <p>Wait for multiple tasks to complete.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of task keys to wait for</p> required <code>timeout</code> <code>float</code> <p>Maximum seconds to wait</p> <code>30.0</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict of key -&gt; value for completed tasks</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.wait_any","title":"wait_any  <code>async</code>","text":"<pre><code>wait_any(\n    keys: list[str], timeout: float = 30.0\n) -&gt; tuple[str, Any] | None\n</code></pre> <p>Wait for any task to complete.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of task keys to wait for</p> required <code>timeout</code> <code>float</code> <p>Maximum seconds to wait</p> <code>30.0</code> <p>Returns:</p> Type Description <code>tuple[str, Any] | None</code> <p>(key, value) tuple for first completed task, or None</p>"},{"location":"api/tasks/#backends","title":"Backends","text":""},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend","title":"BaseBackend","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for task backends.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.enqueue","title":"enqueue  <code>abstractmethod</code>","text":"<pre><code>enqueue(\n    task: Task,\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n    *,\n    session_id: str,\n    key: str,\n) -&gt; TaskResult\n</code></pre> <p>Enqueue a task for execution.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(session_id: str, key: str) -&gt; TaskResult | None\n</code></pre> <p>Get a task result by session and key.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.pop","title":"pop  <code>abstractmethod</code>","text":"<pre><code>pop(session_id: str, key: str) -&gt; Any | None\n</code></pre> <p>Pop a completed result value, removing it from storage.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.pop_all","title":"pop_all  <code>abstractmethod</code>","text":"<pre><code>pop_all(session_id: str) -&gt; list[Any]\n</code></pre> <p>Pop all completed results for a session.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.cancel","title":"cancel  <code>abstractmethod</code>","text":"<pre><code>cancel(session_id: str, key: str) -&gt; bool\n</code></pre> <p>Cancel a pending/running task.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.cancel_all","title":"cancel_all  <code>abstractmethod</code>","text":"<pre><code>cancel_all(session_id: str) -&gt; int\n</code></pre> <p>Cancel all tasks for a session. Returns count cancelled.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.pop_errors","title":"pop_errors  <code>abstractmethod</code>","text":"<pre><code>pop_errors(session_id: str) -&gt; list[tuple[str, Exception]]\n</code></pre> <p>Pop all failed results for a session, returning (key, error) pairs.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.has","title":"has  <code>abstractmethod</code>","text":"<pre><code>has(session_id: str, key: str | None = None) -&gt; bool\n</code></pre> <p>Check if there are any completed results.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.wait","title":"wait  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>wait(\n    session_id: str, key: str, timeout: float = 30.0\n) -&gt; Any | None\n</code></pre> <p>Wait for a specific task to complete.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.wait_all","title":"wait_all  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>wait_all(\n    session_id: str, keys: list[str], timeout: float = 30.0\n) -&gt; dict[str, Any]\n</code></pre> <p>Wait for multiple tasks to complete. Returns dict of key -&gt; value.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.wait_any","title":"wait_any  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>wait_any(\n    session_id: str, keys: list[str], timeout: float = 30.0\n) -&gt; tuple[str, Any] | None\n</code></pre> <p>Wait for any task to complete. Returns (key, value) or None.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend","title":"InMemoryBackend","text":"<p>               Bases: <code>BaseBackend</code></p> <p>In-memory task backend using ThreadPoolExecutor.</p> <p>Tasks are executed in a thread pool and results are stored in memory. Results are automatically cleaned up when expired (lazy cleanup on access).</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.__init__","title":"__init__","text":"<pre><code>__init__(max_workers: int = 4)\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.enqueue","title":"enqueue","text":"<pre><code>enqueue(\n    task: Task,\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n    *,\n    session_id: str,\n    key: str,\n) -&gt; TaskResult\n</code></pre> <p>Enqueue a task for background execution.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.get","title":"get","text":"<pre><code>get(session_id: str, key: str) -&gt; TaskResult | None\n</code></pre> <p>Get a task result by session and key.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.pop","title":"pop","text":"<pre><code>pop(session_id: str, key: str) -&gt; Any | None\n</code></pre> <p>Pop a completed result value, removing it from storage.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.pop_all","title":"pop_all","text":"<pre><code>pop_all(session_id: str) -&gt; list[Any]\n</code></pre> <p>Pop all completed results for a session.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.shutdown","title":"shutdown","text":"<pre><code>shutdown(wait: bool = True) -&gt; None\n</code></pre> <p>Shutdown the thread pool.</p>"},{"location":"api/tasks/#testing","title":"Testing","text":""},{"location":"api/tasks/#fasthooks.tasks.testing.ImmediateBackend","title":"ImmediateBackend","text":"<p>               Bases: <code>BaseBackend</code></p> <p>Backend that executes tasks immediately (synchronously).</p> <p>Useful for testing when you want tasks to complete before assertions. Tracks full lifecycle (status transitions, timestamps).</p> Example <p>backend = ImmediateBackend() app = HookApp(task_backend=backend)</p>"},{"location":"api/tasks/#fasthooks.tasks.testing.ImmediateBackend--tasks-complete-immediately","title":"Tasks complete immediately","text":"<p>client = TestClient(app) response = client.send(MockEvent.bash(command=\"ls\"))</p>"},{"location":"api/tasks/#fasthooks.tasks.testing.ImmediateBackend--results-are-immediately-available","title":"Results are immediately available","text":"<p>assert backend.get(\"session\", \"key\").status == TaskStatus.COMPLETED</p>"},{"location":"api/tasks/#fasthooks.tasks.testing.ImmediateBackend.enqueue","title":"enqueue","text":"<pre><code>enqueue(\n    task: Task,\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n    *,\n    session_id: str,\n    key: str,\n) -&gt; TaskResult\n</code></pre> <p>Execute task immediately (synchronous).</p>"},{"location":"api/testing/","title":"Testing Utilities","text":"<p>Utilities for testing hook handlers.</p>"},{"location":"api/testing/#mockevent","title":"MockEvent","text":"<p>Factory for creating test events.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent","title":"MockEvent","text":"<p>Factory for creating test events.</p> Example <p>event = MockEvent.bash(command=\"ls -la\") result = my_handler(event) assert result.decision != \"deny\"</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.bash","title":"bash  <code>staticmethod</code>","text":"<pre><code>bash(\n    command: str,\n    *,\n    description: str | None = None,\n    timeout: int | None = None,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Bash\n</code></pre> <p>Create a Bash PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.write","title":"write  <code>staticmethod</code>","text":"<pre><code>write(\n    file_path: str,\n    content: str = \"\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Write\n</code></pre> <p>Create a Write PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.edit","title":"edit  <code>staticmethod</code>","text":"<pre><code>edit(\n    file_path: str,\n    old_string: str,\n    new_string: str,\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Edit\n</code></pre> <p>Create an Edit PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.read","title":"read  <code>staticmethod</code>","text":"<pre><code>read(\n    file_path: str,\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Read\n</code></pre> <p>Create a Read PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.grep","title":"grep  <code>staticmethod</code>","text":"<pre><code>grep(\n    pattern: str,\n    *,\n    path: str | None = None,\n    glob: str | None = None,\n    output_mode: str | None = None,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Grep\n</code></pre> <p>Create a Grep PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.glob","title":"glob  <code>staticmethod</code>","text":"<pre><code>glob(\n    pattern: str,\n    *,\n    path: str | None = None,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Glob\n</code></pre> <p>Create a Glob PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.task","title":"task  <code>staticmethod</code>","text":"<pre><code>task(\n    prompt: str,\n    *,\n    description: str = \"Test task\",\n    subagent_type: str | None = None,\n    model: str | None = None,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Task\n</code></pre> <p>Create a Task PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.web_search","title":"web_search  <code>staticmethod</code>","text":"<pre><code>web_search(\n    query: str,\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; WebSearch\n</code></pre> <p>Create a WebSearch PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.web_fetch","title":"web_fetch  <code>staticmethod</code>","text":"<pre><code>web_fetch(\n    url: str,\n    prompt: str = \"\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; WebFetch\n</code></pre> <p>Create a WebFetch PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.stop","title":"stop  <code>staticmethod</code>","text":"<pre><code>stop(\n    *,\n    stop_hook_active: bool = False,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Stop\n</code></pre> <p>Create a Stop event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.subagent_stop","title":"subagent_stop  <code>staticmethod</code>","text":"<pre><code>subagent_stop(\n    *,\n    stop_hook_active: bool = False,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; SubagentStop\n</code></pre> <p>Create a SubagentStop event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.session_start","title":"session_start  <code>staticmethod</code>","text":"<pre><code>session_start(\n    source: str = \"startup\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; SessionStart\n</code></pre> <p>Create a SessionStart event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.session_end","title":"session_end  <code>staticmethod</code>","text":"<pre><code>session_end(\n    reason: str = \"user_exit\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; SessionEnd\n</code></pre> <p>Create a SessionEnd event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.pre_compact","title":"pre_compact  <code>staticmethod</code>","text":"<pre><code>pre_compact(\n    trigger: str = \"manual\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; PreCompact\n</code></pre> <p>Create a PreCompact event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.user_prompt","title":"user_prompt  <code>staticmethod</code>","text":"<pre><code>user_prompt(\n    prompt: str,\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; UserPromptSubmit\n</code></pre> <p>Create a UserPromptSubmit event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.notification","title":"notification  <code>staticmethod</code>","text":"<pre><code>notification(\n    message: str,\n    notification_type: str = \"info\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Notification\n</code></pre> <p>Create a Notification event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.permission_bash","title":"permission_bash  <code>staticmethod</code>","text":"<pre><code>permission_bash(\n    command: str,\n    *,\n    description: str | None = None,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Bash\n</code></pre> <p>Create a Bash PermissionRequest event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.permission_write","title":"permission_write  <code>staticmethod</code>","text":"<pre><code>permission_write(\n    file_path: str,\n    content: str = \"\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Write\n</code></pre> <p>Create a Write PermissionRequest event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.permission_edit","title":"permission_edit  <code>staticmethod</code>","text":"<pre><code>permission_edit(\n    file_path: str,\n    old_string: str,\n    new_string: str,\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Edit\n</code></pre> <p>Create an Edit PermissionRequest event.</p>"},{"location":"api/testing/#testclient","title":"TestClient","text":"<p>Client for testing hook applications.</p>"},{"location":"api/testing/#fasthooks.testing.client.TestClient","title":"TestClient","text":"<p>Test client for invoking hook handlers.</p> <p>Allows testing hooks without stdin/stdout plumbing.</p> Example <p>app = HookApp()</p> <p>@app.pre_tool(\"Bash\") def handler(event):     return allow()</p> <p>client = TestClient(app) response = client.send(MockEvent.bash(command=\"ls\")) assert response is None  # allowed</p>"},{"location":"api/testing/#fasthooks.testing.client.TestClient.__init__","title":"__init__","text":"<pre><code>__init__(app: HookApp)\n</code></pre> <p>Initialize TestClient.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>HookApp</code> <p>HookApp to test</p> required"},{"location":"api/testing/#fasthooks.testing.client.TestClient.send","title":"send","text":"<pre><code>send(event: BaseEvent) -&gt; BaseHookResponse | None\n</code></pre> <p>Send an event to the app and return the response.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BaseEvent</code> <p>Typed event (from MockEvent or manual)</p> required <p>Returns:</p> Type Description <code>BaseHookResponse | None</code> <p>BaseHookResponse if actionable, None if pass-through</p>"},{"location":"api/transcript/","title":"Transcript API Reference","text":"<p>Rich transcript modeling for context engineering.</p>"},{"location":"api/transcript/#transcript","title":"Transcript","text":"<p>Main class for loading and manipulating transcripts.</p> <pre><code>from fasthooks.transcript import Transcript\n</code></pre>"},{"location":"api/transcript/#constructor","title":"Constructor","text":"<pre><code>Transcript(\n    path: str | Path | None = None,\n    auto_load: bool = True,\n    validate: Literal[\"strict\", \"warn\", \"none\"] = \"warn\",\n    include_archived: bool = False,\n    include_meta: bool = False,\n)\n</code></pre> Parameter Description <code>path</code> Path to transcript JSONL file <code>auto_load</code> Load file immediately (default True) <code>validate</code> Unknown block handling: strict=error, warn=warning, none=silent <code>include_archived</code> Include pre-compaction entries in views <code>include_meta</code> Include system meta entries in views"},{"location":"api/transcript/#properties","title":"Properties","text":"Property Type Description <code>entries</code> <code>list[TranscriptEntry]</code> Current context window entries <code>archived</code> <code>list[TranscriptEntry]</code> Pre-compaction entries <code>all_entries</code> <code>list[TranscriptEntry]</code> archived + entries <code>user_messages</code> <code>list[UserMessage]</code> User message entries <code>assistant_messages</code> <code>list[AssistantMessage]</code> Assistant message entries <code>tool_uses</code> <code>list[ToolUseBlock]</code> All tool use blocks <code>tool_results</code> <code>list[ToolResultBlock]</code> All tool result blocks <code>errors</code> <code>list[ToolResultBlock]</code> Tool results with is_error=True <code>turns</code> <code>list[Turn]</code> Entries grouped by requestId <code>compact_boundaries</code> <code>list[CompactBoundary]</code> Compaction markers <code>stats</code> <code>TranscriptStats</code> Aggregated statistics"},{"location":"api/transcript/#crud-methods","title":"CRUD Methods","text":"<pre><code># Insert\ntranscript.insert(index: int, entry: Entry) -&gt; None\ntranscript.append(entry: Entry) -&gt; None\n\n# Remove\ntranscript.remove(entry: Entry, relink: bool = True) -&gt; None\ntranscript.remove_tree(entry: Entry) -&gt; list[Entry]\n\n# Replace\ntranscript.replace(old: Entry, new: Entry) -&gt; None\n\n# Persistence\ntranscript.load() -&gt; None\ntranscript.save() -&gt; None\n\n# Batch operations\nwith transcript.batch():\n    # Auto-commit on success, rollback on exception\n    ...\n</code></pre>"},{"location":"api/transcript/#query-methods","title":"Query Methods","text":"<pre><code>transcript.query(\n    include_archived: bool | None = None,\n    include_meta: bool | None = None,\n) -&gt; TranscriptQuery\n</code></pre>"},{"location":"api/transcript/#lookup-methods","title":"Lookup Methods","text":"<pre><code>transcript.find_by_uuid(uuid: str) -&gt; Entry | None\ntranscript.find_tool_use(tool_use_id: str) -&gt; ToolUseBlock | None\ntranscript.find_tool_result(tool_use_id: str) -&gt; ToolResultBlock | None\ntranscript.find_snapshot(message_id: str) -&gt; FileHistorySnapshot | None\ntranscript.get_parent(entry: Entry) -&gt; Entry | None\ntranscript.get_children(entry: Entry) -&gt; list[Entry]\ntranscript.get_logical_parent(entry: Entry) -&gt; Entry | None\n</code></pre>"},{"location":"api/transcript/#export-methods","title":"Export Methods","text":"<pre><code># To string\ntranscript.to_markdown(**kwargs) -&gt; str\ntranscript.to_html(**kwargs) -&gt; str\ntranscript.to_json(indent: int = 2) -&gt; str\ntranscript.to_jsonl() -&gt; str\n\n# To file\ntranscript.to_file(\n    path: str | Path,\n    format: Literal[\"md\", \"html\", \"json\", \"jsonl\"] = \"md\",\n    **kwargs\n) -&gt; None\n</code></pre>"},{"location":"api/transcript/#transcriptquery","title":"TranscriptQuery","text":"<p>Fluent query builder for filtering entries.</p> <pre><code>query = transcript.query()\n</code></pre>"},{"location":"api/transcript/#type-filters","title":"Type Filters","text":"<pre><code>query.users() -&gt; TranscriptQuery\nquery.assistants() -&gt; TranscriptQuery\nquery.system() -&gt; TranscriptQuery\nquery.with_tools() -&gt; TranscriptQuery\nquery.with_errors() -&gt; TranscriptQuery\nquery.with_thinking() -&gt; TranscriptQuery\n</code></pre>"},{"location":"api/transcript/#filtering","title":"Filtering","text":"<pre><code>query.filter(**kwargs) -&gt; TranscriptQuery\nquery.where(predicate: Callable) -&gt; TranscriptQuery\nquery.exclude(**kwargs) -&gt; TranscriptQuery\n</code></pre> <p>Supported lookups:</p> Lookup Example Description <code>exact</code> <code>filter(type=\"user\")</code> Exact match (default) <code>contains</code> <code>filter(text__contains=\"error\")</code> Substring <code>startswith</code> <code>filter(uuid__startswith=\"abc\")</code> Prefix <code>endswith</code> <code>filter(text__endswith=\"!\")</code> Suffix <code>regex</code> <code>filter(text__regex=r\"\\d+\")</code> Regex match <code>in</code> <code>filter(type__in=[\"user\", \"assistant\"])</code> In list <code>gt</code> <code>filter(timestamp__gt=datetime(...))</code> Greater than <code>gte</code> <code>filter(timestamp__gte=datetime(...))</code> Greater or equal <code>lt</code> <code>filter(timestamp__lt=datetime(...))</code> Less than <code>lte</code> <code>filter(timestamp__lte=datetime(...))</code> Less or equal <code>isnull</code> <code>filter(parent_uuid__isnull=True)</code> Is None"},{"location":"api/transcript/#time-filters","title":"Time Filters","text":"<pre><code>query.since(ts: datetime | str) -&gt; TranscriptQuery\nquery.until(ts: datetime | str) -&gt; TranscriptQuery\n</code></pre>"},{"location":"api/transcript/#ordering","title":"Ordering","text":"<pre><code>query.order_by(*fields: str) -&gt; TranscriptQuery\n# Prefix with - for descending: order_by(\"-timestamp\")\n</code></pre>"},{"location":"api/transcript/#pagination","title":"Pagination","text":"<pre><code>query.limit(n: int) -&gt; TranscriptQuery\nquery.offset(n: int) -&gt; TranscriptQuery\n</code></pre>"},{"location":"api/transcript/#terminals","title":"Terminals","text":"<pre><code>query.all() -&gt; list[TranscriptEntry]\nquery.first() -&gt; TranscriptEntry | None\nquery.last() -&gt; TranscriptEntry | None\nquery.one() -&gt; TranscriptEntry  # Raises if 0 or &gt;1 results\nquery.count() -&gt; int\nquery.exists() -&gt; bool\n</code></pre>"},{"location":"api/transcript/#entry-types","title":"Entry Types","text":""},{"location":"api/transcript/#entry-base","title":"Entry (Base)","text":"<pre><code>class Entry:\n    type: str\n    uuid: str\n    parent_uuid: str | None\n    timestamp: datetime | None\n    session_id: str\n    cwd: str\n    version: str\n    git_branch: str\n    is_sidechain: bool\n    is_synthetic: bool\n</code></pre>"},{"location":"api/transcript/#usermessage","title":"UserMessage","text":"<pre><code>class UserMessage(Entry):\n    type: Literal[\"user\"] = \"user\"\n\n    # Properties\n    content: str | list[ToolResultBlock]\n    text: str  # Empty if tool result\n    is_tool_result: bool\n    tool_results: list[ToolResultBlock]\n\n    # Factory\n    @classmethod\n    def create(\n        cls,\n        content: str,\n        *,\n        parent: Entry | None = None,\n        context: Entry | None = None,\n        **overrides\n    ) -&gt; UserMessage\n</code></pre>"},{"location":"api/transcript/#assistantmessage","title":"AssistantMessage","text":"<pre><code>class AssistantMessage(Entry):\n    type: Literal[\"assistant\"] = \"assistant\"\n    request_id: str\n\n    # Properties\n    message_id: str\n    model: str\n    content: list[ContentBlock]\n    stop_reason: str | None\n    usage: dict\n    text: str\n    thinking: str\n    tool_uses: list[ToolUseBlock]\n    has_tool_use: bool\n\n    # Factory\n    @classmethod\n    def create(\n        cls,\n        content: str | list[ContentBlock],\n        *,\n        parent: Entry | None = None,\n        context: Entry | None = None,\n        model: str = \"synthetic\",\n        stop_reason: str = \"end_turn\",\n        **overrides\n    ) -&gt; AssistantMessage\n</code></pre>"},{"location":"api/transcript/#systementry","title":"SystemEntry","text":"<pre><code>class SystemEntry(Entry):\n    type: Literal[\"system\"] = \"system\"\n    subtype: str\n    content: str\n    level: str\n</code></pre>"},{"location":"api/transcript/#compactboundary","title":"CompactBoundary","text":"<pre><code>class CompactBoundary(SystemEntry):\n    subtype: Literal[\"compact_boundary\"] = \"compact_boundary\"\n    logical_parent_uuid: str\n    compact_metadata: dict\n</code></pre>"},{"location":"api/transcript/#content-blocks","title":"Content Blocks","text":""},{"location":"api/transcript/#textblock","title":"TextBlock","text":"<pre><code>class TextBlock:\n    type: Literal[\"text\"] = \"text\"\n    text: str\n</code></pre>"},{"location":"api/transcript/#tooluseblock","title":"ToolUseBlock","text":"<pre><code>class ToolUseBlock:\n    type: Literal[\"tool_use\"] = \"tool_use\"\n    id: str\n    name: str\n    input: dict\n\n    # Property - finds matching result\n    result: ToolResultBlock | None\n</code></pre>"},{"location":"api/transcript/#toolresultblock","title":"ToolResultBlock","text":"<pre><code>class ToolResultBlock:\n    type: Literal[\"tool_result\"] = \"tool_result\"\n    tool_use_id: str\n    content: str\n    is_error: bool\n\n    # Property - finds matching tool use\n    tool_use: ToolUseBlock | None\n</code></pre>"},{"location":"api/transcript/#thinkingblock","title":"ThinkingBlock","text":"<pre><code>class ThinkingBlock:\n    type: Literal[\"thinking\"] = \"thinking\"\n    thinking: str\n    signature: str  # Cryptographic signature (read-only)\n</code></pre>"},{"location":"api/transcript/#turn","title":"Turn","text":"<p>Groups assistant entries by requestId.</p> <pre><code>class Turn:\n    request_id: str\n    entries: list[AssistantMessage]\n\n    # Properties\n    thinking: str\n    text: str\n    tool_uses: list[ToolUseBlock]\n    is_complete: bool\n    has_error: bool\n</code></pre>"},{"location":"api/transcript/#transcriptstats","title":"TranscriptStats","text":"<pre><code>class TranscriptStats:\n    input_tokens: int\n    output_tokens: int\n    cache_read_tokens: int\n    cache_creation_tokens: int\n    tool_calls: dict[str, int]\n    error_count: int\n    message_count: int\n    turn_count: int\n    compact_count: int\n    duration_seconds: float\n    slug: str\n</code></pre>"},{"location":"api/transcript/#factory-functions","title":"Factory Functions","text":""},{"location":"api/transcript/#inject_tool_result","title":"inject_tool_result","text":"<pre><code>from fasthooks.transcript import inject_tool_result\n\ninject_tool_result(\n    transcript: Transcript,\n    tool_name: str,\n    tool_input: dict,\n    result: str,\n    *,\n    is_error: bool = False,\n    position: int | Literal[\"start\", \"end\"] = \"end\",\n) -&gt; tuple[AssistantMessage, UserMessage]\n</code></pre> <p>Creates a matching ToolUseBlock + ToolResultBlock pair and inserts them.</p>"},{"location":"comparison/","title":"Comparisons","text":"<p>How does fasthooks compare to other approaches for building Claude Code hooks?</p>"},{"location":"comparison/#hook-libraries-frameworks","title":"Hook Libraries &amp; Frameworks","text":"Library Approach Best For cchooks Context factory (Python) Simple hooks Claude Agent SDK In-process callbacks SDK-based applications claude-mem Memory plugin (observer) Persistent AI memory Continuous-Claude-v2 Session continuity Long-running projects Raw JSON Protocol Manual stdin/stdout One-off scripts fasthooks Decorator framework (Python) CLI hook development"},{"location":"comparison/#quick-summary","title":"Quick Summary","text":"<p>fasthooks is a batteries-included framework for building Claude Code hooks with:</p> <ul> <li>Typed events with property accessors</li> <li>Response helpers (<code>allow()</code>, <code>deny()</code>, <code>block()</code>)</li> <li>Dependency injection (<code>State</code>, <code>Transcript</code>, <code>Tasks</code>)</li> <li>Background tasks for async work</li> <li>Blueprints and middleware for modularity</li> <li>Testing utilities</li> </ul> <p>cchooks is a minimal Python SDK using a context factory pattern. Explicit and lightweight, but no state management, middleware, or testing utilities. Good for simple, single-purpose hooks.</p> <p>Claude Agent SDK hooks are lightweight in-process callbacks for applications that embed Claude via the SDK. They're minimal by design - no state management, no transcript parsing, no DX conveniences.</p> <p>claude-mem is a complete memory plugin that uses hooks internally to observe tool usage. It cannot block or deny - it's an observer, not an enforcer. Great for persistent memory, not for building custom hook logic.</p> <p>Continuous-Claude-v2 is a session continuity system using hooks to preserve context across <code>/clear</code> and compaction. Features ledgers, handoffs, TypeScript preflight, and skill auto-activation. Can block on PreToolUse only.</p> <p>Raw JSON protocol is what all approaches build on. Use it directly only for simple one-off scripts.</p>"},{"location":"comparison/#detailed-comparisons","title":"Detailed Comparisons","text":"<ul> <li>cchooks - Minimal Python SDK vs batteries-included framework</li> <li>Claude Agent SDK Hooks - In-depth comparison of SDK hooks vs fasthooks</li> <li>claude-mem - Memory plugin vs hook framework</li> <li>Continuous-Claude-v2 - Session continuity system vs hook framework</li> </ul>"},{"location":"comparison/cchooks/","title":"cchooks vs fasthooks","text":"<p>cchooks is a Python SDK for building Claude Code hooks. This is the most direct comparison - both libraries solve the same problem with different approaches.</p>"},{"location":"comparison/cchooks/#same-goal-different-approaches","title":"Same Goal, Different Approaches","text":"Aspect cchooks fasthooks Pattern Context factory Decorator handlers Philosophy Minimal, explicit Batteries-included API Style <code>create_context()</code> \u2192 methods <code>@app.pre_tool()</code> \u2192 return <p>Both eliminate JSON boilerplate and provide type-safe hook development.</p>"},{"location":"comparison/cchooks/#architecture","title":"Architecture","text":""},{"location":"comparison/cchooks/#cchooks-context-factory-pattern","title":"cchooks: Context Factory Pattern","text":"<pre><code>from cchooks import create_context, PreToolUseContext\n\nc = create_context()  # Reads stdin, detects hook type\nassert isinstance(c, PreToolUseContext)\n\nif c.tool_name == \"Bash\" and \"rm -rf\" in c.tool_input.get(\"command\", \"\"):\n    c.output.deny(reason=\"Dangerous command blocked\")\nelse:\n    c.output.allow()\n</code></pre> <p>Flow: stdin \u2192 <code>create_context()</code> \u2192 type-specific context \u2192 <code>output.method()</code></p>"},{"location":"comparison/cchooks/#fasthooks-decorator-handlers","title":"fasthooks: Decorator Handlers","text":"<pre><code>from fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Flow: stdin \u2192 <code>app.run()</code> \u2192 route to handler \u2192 return response</p>"},{"location":"comparison/cchooks/#event-coverage","title":"Event Coverage","text":"<p>Both support all Claude Code hook events:</p> Event cchooks fasthooks PreToolUse \u2705 \u2705 PostToolUse \u2705 \u2705 Stop \u2705 \u2705 SubagentStop \u2705 \u2705 SessionStart \u2705 \u2705 SessionEnd \u2705 \u2705 UserPromptSubmit \u2705 \u2705 Notification \u2705 \u2705 PreCompact \u2705 \u2705 PermissionRequest \u274c \u2705"},{"location":"comparison/cchooks/#response-format","title":"Response Format","text":""},{"location":"comparison/cchooks/#cchooks-method-calls","title":"cchooks: Method Calls","text":"<pre><code># PreToolUse\nc.output.allow()\nc.output.deny(reason=\"Blocked\", system_message=\"Warning\")\nc.output.ask(reason=\"Please confirm\")\n\n# Stop\nc.output.prevent(reason=\"Keep working\")\nc.output.halt(reason=\"Fatal error\")\n\n# SessionStart\nc.output.add_context(\"Additional context for Claude\")\n\n# Exit codes\nc.output.exit_success()      # exit 0\nc.output.exit_non_block()    # exit 1\nc.output.exit_block()        # exit 2\n</code></pre>"},{"location":"comparison/cchooks/#fasthooks-return-values","title":"fasthooks: Return Values","text":"<pre><code>from fasthooks import allow, deny, block\n\n@app.pre_tool(\"Bash\")\ndef check(event):\n    return deny(\"Blocked\")           # Prevent execution\n    return allow(message=\"OK\")       # Continue\n    return None                      # Allow (implicit)\n\n@app.on_stop()\ndef check_stop(event):\n    return block(\"Keep working\")     # Prevent stop\n</code></pre> Action cchooks fasthooks Allow tool <code>c.output.allow()</code> <code>return allow()</code> or <code>None</code> Deny tool <code>c.output.deny(reason=...)</code> <code>return deny(\"reason\")</code> Prevent stop <code>c.output.prevent(reason=...)</code> <code>return block(\"reason\")</code> Add context <code>c.output.add_context(...)</code> <code>return allow(message=...)</code>"},{"location":"comparison/cchooks/#type-safety","title":"Type Safety","text":""},{"location":"comparison/cchooks/#cchooks-context-classes","title":"cchooks: Context Classes","text":"<pre><code>from cchooks import PreToolUseContext\n\nc = create_context()\nassert isinstance(c, PreToolUseContext)\n\nc.tool_name      # str\nc.tool_input     # dict[str, Any]\nc.session_id     # str\nc.transcript_path # str\nc.cwd            # str\n</code></pre> <p>Manual dict access for tool_input: <code>c.tool_input.get(\"command\", \"\")</code></p>"},{"location":"comparison/cchooks/#fasthooks-pydantic-models-with-properties","title":"fasthooks: Pydantic Models with Properties","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef check(event):\n    event.command      # str - direct property\n    event.description  # str | None\n    event.timeout      # int | None\n    event.tool_input   # dict - raw access if needed\n</code></pre> <p>IDE autocomplete works on properties like <code>event.command</code>.</p>"},{"location":"comparison/cchooks/#handler-registration","title":"Handler Registration","text":""},{"location":"comparison/cchooks/#cchooks-single-entry-point","title":"cchooks: Single Entry Point","text":"<pre><code># hook.py - handles ONE hook type\nfrom cchooks import create_context, PreToolUseContext\n\nc = create_context()\n# Must check type manually\nif isinstance(c, PreToolUseContext):\n    # handle PreToolUse\n</code></pre> <p>Each hook type = separate file (or manual dispatch).</p>"},{"location":"comparison/cchooks/#fasthooks-multiple-handlers","title":"fasthooks: Multiple Handlers","text":"<pre><code># hooks.py - handles ALL hook types\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event): ...\n\n@app.pre_tool(\"Write\")\ndef check_write(event): ...\n\n@app.on_stop()\ndef on_stop(event): ...\n\napp.run()  # Routes automatically\n</code></pre> <p>One file can handle multiple events with automatic routing.</p>"},{"location":"comparison/cchooks/#tool-matching","title":"Tool Matching","text":""},{"location":"comparison/cchooks/#cchooks-manual-check","title":"cchooks: Manual Check","text":"<pre><code>c = create_context()\nif c.tool_name == \"Bash\":\n    # handle Bash\nelif c.tool_name in [\"Write\", \"Edit\"]:\n    # handle Write/Edit\n</code></pre>"},{"location":"comparison/cchooks/#fasthooks-decorator-routing-guards","title":"fasthooks: Decorator Routing + Guards","text":"<pre><code>@app.pre_tool(\"Bash\")           # Single tool\ndef check_bash(event): ...\n\n@app.pre_tool(\"Write\", \"Edit\")  # Multiple tools\ndef check_write(event): ...\n\n@app.pre_tool()                 # Catch-all\ndef check_any(event): ...\n\n@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)\ndef check_sudo(event): ...      # Conditional\n</code></pre>"},{"location":"comparison/cchooks/#state-management","title":"State Management","text":""},{"location":"comparison/cchooks/#cchooks-none-built-in","title":"cchooks: None Built-in","text":"<pre><code># Must manually implement persistence\nimport json\nfrom pathlib import Path\n\nSTATE_FILE = Path.home() / \".my-hook-state.json\"\n\nc = create_context()\nstate = json.loads(STATE_FILE.read_text()) if STATE_FILE.exists() else {}\nstate[\"count\"] = state.get(\"count\", 0) + 1\nSTATE_FILE.write_text(json.dumps(state))\n</code></pre>"},{"location":"comparison/cchooks/#fasthooks-dependency-injection","title":"fasthooks: Dependency Injection","text":"<pre><code>from fasthooks.depends import State, Transcript\n\n@app.pre_tool(\"Bash\")\ndef check(event, state: State, transcript: Transcript):\n    # state: auto-loaded JSON, session-scoped\n    state[\"count\"] = state.get(\"count\", 0) + 1\n    state.save()\n\n    # transcript: parsed conversation history\n    if transcript.stats.tool_calls.get(\"Bash\", 0) &gt; 100:\n        return deny(\"Rate limit exceeded\")\n</code></pre>"},{"location":"comparison/cchooks/#feature-comparison","title":"Feature Comparison","text":"Feature cchooks fasthooks Typed Events \u2705 (context classes) \u2705 (Pydantic models) Property Accessors \u274c (dict access) \u2705 (<code>event.command</code>) Response Helpers \u2705 (methods) \u2705 (functions) Multi-Handler Routing \u274c \u2705 Guards/Filters \u274c \u2705 (<code>when=</code>) Catch-All Handlers \u274c \u2705 (<code>@app.pre_tool()</code>) State Persistence \u274c \u2705 (<code>State</code>) Transcript Parsing \u274c \u2705 (<code>Transcript</code>) Background Tasks \u274c \u2705 (<code>Tasks</code>) Blueprints \u274c \u2705 Middleware \u274c \u2705 Testing Utils \u274c \u2705 (<code>MockEvent</code>, <code>TestClient</code>) Tool Input Modification \u2705 (<code>updated_input</code>) \u274c Safe Error Handling \u2705 (<code>safe_create_context</code>) \u2705"},{"location":"comparison/cchooks/#unique-to-cchooks","title":"Unique to cchooks","text":""},{"location":"comparison/cchooks/#tool-input-modification","title":"Tool Input Modification","text":"<p>cchooks can modify tool inputs before execution:</p> <pre><code>c = create_context()\nif c.tool_name == \"Write\":\n    # Redirect writes to safe location\n    c.output.allow(\n        updated_input={\"file_path\": \"/safe/location/\" + c.tool_input[\"file_path\"]}\n    )\n</code></pre> <p>fasthooks currently doesn't support <code>updated_input</code>.</p>"},{"location":"comparison/cchooks/#exit-code-control","title":"Exit Code Control","text":"<p>cchooks provides explicit exit code methods:</p> <pre><code>c.output.exit_success()      # exit 0 - success, stdout in transcript\nc.output.exit_non_block()    # exit 1 - error shown to user\nc.output.exit_block()        # exit 2 - blocking error\n</code></pre>"},{"location":"comparison/cchooks/#unique-to-fasthooks","title":"Unique to fasthooks","text":""},{"location":"comparison/cchooks/#dependency-injection","title":"Dependency Injection","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef handler(event, state: State, transcript: Transcript, tasks: Tasks):\n    # All injected automatically based on type hints\n</code></pre>"},{"location":"comparison/cchooks/#blueprints","title":"Blueprints","text":"<pre><code>security = Blueprint()\n\n@security.pre_tool(\"Bash\")\ndef no_sudo(event):\n    if \"sudo\" in event.command:\n        return deny(\"No sudo\")\n\napp.include(security)\n</code></pre>"},{"location":"comparison/cchooks/#middleware","title":"Middleware","text":"<pre><code>@app.middleware\ndef timing(event, call_next):\n    start = time.time()\n    response = call_next(event)\n    print(f\"Hook took {time.time() - start:.3f}s\")\n    return response\n</code></pre>"},{"location":"comparison/cchooks/#testing-utilities","title":"Testing Utilities","text":"<pre><code>from fasthooks.testing import MockEvent, TestClient\n\ndef test_blocks_rm():\n    client = TestClient(app)\n    response = client.send(MockEvent.bash(command=\"rm -rf /\"))\n    assert response.decision == \"deny\"\n</code></pre>"},{"location":"comparison/cchooks/#background-tasks","title":"Background Tasks","text":"<pre><code>from fasthooks.tasks import task, Tasks\n\n@task\ndef analyze(code: str) -&gt; str:\n    return expensive_analysis(code)\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(analyze, event.content)\n</code></pre>"},{"location":"comparison/cchooks/#code-comparison","title":"Code Comparison","text":""},{"location":"comparison/cchooks/#blocking-dangerous-commands","title":"Blocking Dangerous Commands","text":"<p>cchooks: <pre><code>#!/usr/bin/env python3\nfrom cchooks import create_context, PreToolUseContext\n\nc = create_context()\nassert isinstance(c, PreToolUseContext)\n\nif c.tool_name == \"Bash\":\n    cmd = c.tool_input.get(\"command\", \"\")\n    if \"rm -rf\" in cmd:\n        c.output.deny(reason=\"Dangerous command blocked\")\n    else:\n        c.output.allow()\nelse:\n    c.output.allow()\n</code></pre></p> <p>fasthooks: <pre><code>#!/usr/bin/env python3\nfrom fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre></p>"},{"location":"comparison/cchooks/#rate-limiting-with-state","title":"Rate Limiting with State","text":"<p>cchooks: <pre><code>#!/usr/bin/env python3\nimport json\nfrom pathlib import Path\nfrom cchooks import create_context, PreToolUseContext\n\nSTATE_FILE = Path.home() / \".hook-state.json\"\n\nc = create_context()\nassert isinstance(c, PreToolUseContext)\n\n# Manual state management\nstate = json.loads(STATE_FILE.read_text()) if STATE_FILE.exists() else {}\ncount = state.get(\"bash_count\", 0) + 1\nstate[\"bash_count\"] = count\nSTATE_FILE.write_text(json.dumps(state))\n\nif count &gt; 100:\n    c.output.deny(reason=f\"Rate limit: {count}/100 commands\")\nelse:\n    c.output.allow()\n</code></pre></p> <p>fasthooks: <pre><code>#!/usr/bin/env python3\nfrom fasthooks import HookApp, deny\nfrom fasthooks.depends import State\n\napp = HookApp(state_dir=\"/tmp/hook-state\")\n\n@app.pre_tool(\"Bash\")\ndef rate_limit(event, state: State):\n    count = state.get(\"bash_count\", 0) + 1\n    state[\"bash_count\"] = count\n    state.save()\n\n    if count &gt; 100:\n        return deny(f\"Rate limit: {count}/100 commands\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre></p>"},{"location":"comparison/cchooks/#when-to-use-each","title":"When to Use Each","text":""},{"location":"comparison/cchooks/#use-cchooks-when","title":"Use cchooks When:","text":"<ul> <li>You want a minimal, lightweight SDK</li> <li>You prefer explicit control over magic</li> <li>You need tool input modification (<code>updated_input</code>)</li> <li>You're building simple, single-purpose hooks</li> <li>You don't need state management or testing utilities</li> </ul>"},{"location":"comparison/cchooks/#use-fasthooks-when","title":"Use fasthooks When:","text":"<ul> <li>You want batteries-included with DI, state, transcripts</li> <li>You prefer decorator-based handler registration</li> <li>You need multiple handlers in one file</li> <li>You want guards and filters for conditional logic</li> <li>You need testing utilities for TDD</li> <li>You're building complex, multi-event hook systems</li> <li>You want blueprints for modular organization</li> </ul>"},{"location":"comparison/cchooks/#summary","title":"Summary","text":"Aspect cchooks fasthooks Philosophy Minimal, explicit Batteries-included API Style Context factory Decorators Learning Curve Lower Slightly higher Boilerplate More Less Features Core only Rich ecosystem Best For Simple hooks Complex systems"},{"location":"comparison/claude-agent-sdk/","title":"Claude Agent SDK Hooks vs fasthooks","text":"<p>The Claude Agent SDK provides in-process hook callbacks for applications that embed Claude. This page compares SDK hooks with fasthooks.</p>"},{"location":"comparison/claude-agent-sdk/#architecture","title":"Architecture","text":"Aspect Claude Agent SDK fasthooks Execution Model In-process async callback Subprocess per hook call Protocol Bidirectional stream (SDK \u2194 CLI) Stdin/stdout JSON Context Runs inside SDK application Spawned by Claude Code CLI Async Required (<code>async def</code>) Optional <p>SDK hooks run inside your Python application alongside the SDK client. The CLI sends hook events over a bidirectional stream, and your callback responds immediately.</p> <p>fasthooks runs as a separate process spawned by Claude Code. Each hook invocation starts a fresh process, reads JSON from stdin, and writes the response to stdout.</p>"},{"location":"comparison/claude-agent-sdk/#event-coverage","title":"Event Coverage","text":"Event SDK fasthooks PreToolUse \u2705 \u2705 PostToolUse \u2705 \u2705 UserPromptSubmit \u2705 \u2705 Stop \u2705 \u2705 SubagentStop \u2705 \u2705 PreCompact \u2705 \u2705 SessionStart \u274c \u2705 SessionEnd \u274c \u2705 Notification \u274c \u2705 PermissionRequest \u274c* \u2705 <p>*SDK uses <code>can_use_tool</code> callback instead of PermissionRequest hooks.</p> <p>SDK Limitations</p> <p>The SDK documentation states: \"Due to setup limitations, the Python SDK does not support SessionStart, SessionEnd, and Notification hooks.\"</p>"},{"location":"comparison/claude-agent-sdk/#developer-experience","title":"Developer Experience","text":""},{"location":"comparison/claude-agent-sdk/#sdk-hooks-manual-verbose","title":"SDK Hooks - Manual &amp; Verbose","text":"<pre><code>from claude_agent_sdk import ClaudeAgentOptions, ClaudeSDKClient, HookMatcher\n\nasync def check_bash(input_data, tool_use_id, context):\n    # Manual tool name check (no routing)\n    if input_data[\"tool_name\"] != \"Bash\":\n        return {}\n\n    # Manual dict access (no typed properties)\n    command = input_data[\"tool_input\"].get(\"command\", \"\")\n\n    if \"rm -rf\" in command:\n        # Manual response dict construction\n        return {\n            \"hookSpecificOutput\": {\n                \"hookEventName\": \"PreToolUse\",\n                \"permissionDecision\": \"deny\",\n                \"permissionDecisionReason\": \"Dangerous command blocked\",\n            }\n        }\n    return {}\n\n# Manual registration\noptions = ClaudeAgentOptions(\n    hooks={\n        \"PreToolUse\": [\n            HookMatcher(matcher=\"Bash\", hooks=[check_bash]),\n        ],\n    }\n)\n\nasync with ClaudeSDKClient(options=options) as client:\n    await client.query(\"Run rm -rf /\")\n    async for msg in client.receive_response():\n        print(msg)\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#fasthooks-concise-typed","title":"fasthooks - Concise &amp; Typed","text":"<pre><code>from fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")  # Decorator routing\ndef check_bash(event):\n    # Typed property access\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")  # Helper function\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Key DX differences:</p> Aspect SDK fasthooks Routing Manual <code>if tool_name</code> check <code>@app.pre_tool(\"Bash\")</code> decorator Event access <code>input_data[\"tool_input\"][\"command\"]</code> <code>event.command</code> Response Raw dict with nested structure <code>deny(\"reason\")</code> Registration Dict in options Decorator"},{"location":"comparison/claude-agent-sdk/#feature-matrix","title":"Feature Matrix","text":"Feature SDK fasthooks Typed events TypedDict Pydantic + properties Response helpers \u274c <code>allow()</code>, <code>deny()</code>, <code>block()</code> Tool matchers String only Decorators + <code>when=</code> guards Multiple tools <code>\"Write\\|Edit\"</code> regex <code>@app.pre_tool(\"Write\", \"Edit\")</code> Catch-all <code>matcher=None</code> <code>@app.pre_tool()</code> or <code>\"*\"</code> State persistence \u274c <code>State</code> dependency Transcript parsing \u274c <code>Transcript</code> dependency Background tasks \u274c <code>Tasks</code> dependency Blueprints \u274c <code>Blueprint</code> class Middleware \u274c <code>@app.middleware</code> Testing utils \u274c <code>MockEvent</code>, <code>TestClient</code>"},{"location":"comparison/claude-agent-sdk/#statefulness","title":"Statefulness","text":""},{"location":"comparison/claude-agent-sdk/#sdk-hooks-stateless","title":"SDK Hooks - Stateless","text":"<p>SDK hooks have no built-in state management. Each callback is stateless:</p> <pre><code># SDK: No state between calls\nasync def my_hook(input_data, tool_use_id, context):\n    # Must manually read transcript_path if you need history\n    transcript_path = input_data.get(\"transcript_path\")\n    # Must implement your own persistence\n    return {}\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#fasthooks-built-in-state-transcript","title":"fasthooks - Built-in State &amp; Transcript","text":"<pre><code>from fasthooks.depends import State, Transcript\n\n@app.pre_tool(\"Bash\")\ndef rate_limit(event, state: State, transcript: Transcript):\n    # state: persisted dict (JSON file per session)\n    count = state.get(\"bash_count\", 0) + 1\n    state[\"bash_count\"] = count\n    state.save()\n\n    # transcript: parsed history with aggregated stats\n    stats = transcript.stats\n    if stats.tool_calls.get(\"Bash\", 0) &gt; 100:\n        return deny(f\"Rate limit: {stats.tool_calls['Bash']} bash commands\")\n\n    # Access token usage, duration, file counts, etc.\n    print(f\"Session tokens: {stats.total_tokens}\")\n    print(f\"Duration: {stats.duration_seconds}s\")\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#background-tasks","title":"Background Tasks","text":"<p>SDK hooks have no background task support. fasthooks provides async work that feeds back in subsequent hooks:</p> <pre><code>from fasthooks.tasks import task, Tasks\n\n@task\ndef analyze_code(code: str) -&gt; str:\n    # Runs in thread pool, non-blocking\n    return expensive_analysis(code)\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(analyze_code, event.content)  # Fire and forget\n    return allow()\n\n@app.on_prompt()\ndef check_analysis(event, tasks: Tasks):\n    if result := tasks.pop(analyze_code):  # Check if done\n        return allow(message=f\"Analysis: {result}\")\n    return allow()\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#when-to-use-each","title":"When to Use Each","text":""},{"location":"comparison/claude-agent-sdk/#use-sdk-hooks-when","title":"Use SDK Hooks When:","text":"<ul> <li>Building an application that embeds Claude via the SDK</li> <li>You need in-process callbacks (no subprocess overhead)</li> <li>You're already using <code>ClaudeSDKClient</code> for custom tools</li> <li>You want hooks and custom MCP tools in the same process</li> </ul> <pre><code># SDK: Hooks + custom tools in one application\noptions = ClaudeAgentOptions(\n    mcp_servers={\"tools\": my_sdk_mcp_server},\n    hooks={\"PreToolUse\": [HookMatcher(matcher=\"Bash\", hooks=[my_hook])]},\n)\n\nasync with ClaudeSDKClient(options=options) as client:\n    # Interactive conversation with hooks\n    await client.query(\"...\")\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#use-fasthooks-when","title":"Use fasthooks When:","text":"<ul> <li>You're a CLI user customizing Claude Code behavior</li> <li>You need persistent state across hook invocations</li> <li>You need transcript analysis (token counts, tool usage stats)</li> <li>You need background async work (API calls, Claude sub-agents)</li> <li>You need SessionStart, SessionEnd, or Notification events</li> <li>You're building reusable hook libraries</li> <li>You want FastAPI-like DX with dependency injection</li> </ul> <pre><code># fasthooks: Standalone hook with full features\nfrom fasthooks import HookApp, allow, deny\nfrom fasthooks.depends import State, Transcript\nfrom fasthooks.tasks import Tasks\n\napp = HookApp(state_dir=\"/tmp/hooks-state\")\n\n@app.pre_tool(\"Bash\")\ndef check(event, state: State, transcript: Transcript, tasks: Tasks):\n    # Full access to state, history, and background tasks\n    ...\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#migration-path","title":"Migration Path","text":"<p>If you're using SDK hooks and want fasthooks features:</p> <p>Option 1: Use fasthooks for CLI hooks, SDK for embedded apps</p> <p>They serve different use cases and can coexist.</p> <p>Option 2: Call fasthooks from SDK hooks</p> <p>For complex logic, you could spawn fasthooks as a subprocess from SDK hooks, though this adds overhead.</p> <p>Option 3: Use fasthooks' Claude sub-agent integration</p> <p>fasthooks can spawn Claude sub-agents via the SDK for AI-powered background tasks:</p> <pre><code>from fasthooks.contrib.claude import agent_task, ClaudeAgent\nfrom fasthooks.tasks import Tasks\n\n@agent_task(model=\"haiku\", system_prompt=\"Review code for bugs.\")\nasync def review_code(agent: ClaudeAgent, code: str) -&gt; str:\n    return await agent.query(f\"Review:\\n{code}\")\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(review_code, event.content)\n    return allow()\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#summary","title":"Summary","text":"Aspect SDK Hooks fasthooks Philosophy Minimal, in-process Batteries-included framework Best for SDK applications CLI hook development DX Manual, verbose FastAPI-like, concise State DIY Built-in Events 6 types 9+ types Ecosystem Part of SDK Standalone library"},{"location":"comparison/claude-mem/","title":"claude-mem vs fasthooks","text":"<p>claude-mem is a Claude Code plugin that provides persistent AI memory across sessions. This page compares its hook implementation with fasthooks.</p>"},{"location":"comparison/claude-mem/#different-goals","title":"Different Goals","text":"Aspect claude-mem fasthooks Primary Purpose Persistent memory system Hook development framework Philosophy Observer (capture &amp; store) Enforcer (validate &amp; control) Can Block Claude? No - always allows Yes - <code>deny()</code>, <code>block()</code> Target User End users wanting memory Developers building hooks <p>claude-mem is a complete application that happens to use hooks internally. It captures tool usage, generates semantic observations via Claude, and injects context into new sessions.</p> <p>fasthooks is a framework for building custom hooks with any logic you need - security policies, rate limiting, code review, etc.</p>"},{"location":"comparison/claude-mem/#architecture-comparison","title":"Architecture Comparison","text":""},{"location":"comparison/claude-mem/#claude-mem-http-client-worker-service","title":"claude-mem: HTTP Client + Worker Service","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Claude Code Session                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 (spawns hooks)\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Hook Scripts (Node.js)                         \u2502\n\u2502  - context-hook.js                              \u2502\n\u2502  - save-hook.js                                 \u2502\n\u2502  - summary-hook.js                              \u2502\n\u2502  - new-hook.js                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 (HTTP requests)\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Worker Service (localhost:37777)               \u2502\n\u2502  - Express HTTP server                          \u2502\n\u2502  - SQLite + Chroma storage                      \u2502\n\u2502  - Claude Agent SDK for observations            \u2502\n\u2502  - Web UI viewer                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Hooks are thin HTTP clients that delegate to a persistent worker service.</p>"},{"location":"comparison/claude-mem/#fasthooks-self-contained-subprocess","title":"fasthooks: Self-Contained Subprocess","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Claude Code Session                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 (spawns hook)\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  fasthooks Process                              \u2502\n\u2502  - Read JSON from stdin                         \u2502\n\u2502  - Route to handler via decorators              \u2502\n\u2502  - Execute handler with DI dependencies         \u2502\n\u2502  - Write JSON response to stdout                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Each hook invocation is self-contained with built-in state persistence.</p>"},{"location":"comparison/claude-mem/#hook-response-model","title":"Hook Response Model","text":""},{"location":"comparison/claude-mem/#claude-mem-observer-only","title":"claude-mem: Observer Only","text":"<pre><code>// claude-mem always returns \"continue\"\nexport const STANDARD_HOOK_RESPONSE = JSON.stringify({\n  continue: true,\n  suppressOutput: true\n});\n\n// Only SessionStart can inject context\nconsole.log(JSON.stringify({\n  hookSpecificOutput: {\n    hookEventName: \"SessionStart\",\n    additionalContext: \"Previous session context...\",\n  },\n}));\n</code></pre> <p>Cannot prevent tool execution - hooks observe and record, never block.</p>"},{"location":"comparison/claude-mem/#fasthooks-full-control","title":"fasthooks: Full Control","text":"<pre><code>from fasthooks import allow, deny, block\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")  # Prevents execution\n    return allow()\n\n@app.on_stop()\ndef prevent_stop(event):\n    if not all_tests_passed():\n        return block(\"Tests still failing\")  # Keeps Claude working\n    return allow()\n</code></pre> <p>Full enforcement capability - allow, deny, block, modify inputs.</p>"},{"location":"comparison/claude-mem/#event-coverage","title":"Event Coverage","text":"Event claude-mem fasthooks PreToolUse \u274c \u2705 PostToolUse \u2705 \u2705 Stop \u2705 \u2705 SubagentStop \u274c \u2705 SessionStart \u2705 \u2705 SessionEnd \u274c \u2705 UserPromptSubmit \u2705 \u2705 Notification \u274c \u2705 PreCompact \u274c \u2705 PermissionRequest \u274c \u2705 <p>claude-mem only implements events needed for memory capture. fasthooks supports all Claude Code hook events.</p>"},{"location":"comparison/claude-mem/#type-safety","title":"Type Safety","text":""},{"location":"comparison/claude-mem/#claude-mem-interfaces-no-validation","title":"claude-mem: Interfaces (No Validation)","text":"<pre><code>// Interface defined but not validated at runtime\nexport interface PostToolUseInput {\n  session_id: string;\n  cwd: string;\n  tool_name: string;\n  tool_input: any;      // No type safety\n  tool_response: any;   // No type safety\n}\n\n// Manual JSON parsing, no validation\nconst parsed = input ? JSON.parse(input) : undefined;\nawait saveHook(parsed);  // May fail at runtime\n</code></pre>"},{"location":"comparison/claude-mem/#fasthooks-pydantic-models-with-properties","title":"fasthooks: Pydantic Models with Properties","text":"<pre><code># Validated Pydantic models with typed properties\n@app.pre_tool(\"Bash\")\ndef handler(event):\n    event.command      # str - typed, autocomplete works\n    event.description  # str | None\n    event.timeout      # int | None\n    event.tool_input   # dict - full access if needed\n</code></pre>"},{"location":"comparison/claude-mem/#state-management","title":"State Management","text":""},{"location":"comparison/claude-mem/#claude-mem-external-database","title":"claude-mem: External Database","text":"<pre><code>// Hooks call worker API, worker manages SQLite + Chroma\nconst response = await fetch(`http://127.0.0.1:${port}/api/sessions/observations`, {\n  method: 'POST',\n  body: JSON.stringify({ contentSessionId, tool_name, tool_input, tool_response })\n});\n\n// Worker handles:\n// - SQLite for structured data (sessions, observations, summaries)\n// - Chroma for vector search (semantic embeddings)\n// - Settings JSON file\n</code></pre> <p>Pros: Rich storage (SQL + vector), shared across hooks Cons: Requires running worker service, HTTP overhead</p>"},{"location":"comparison/claude-mem/#fasthooks-dependency-injection","title":"fasthooks: Dependency Injection","text":"<pre><code>from fasthooks.depends import State, Transcript\n\n@app.pre_tool(\"Bash\")\ndef handler(event, state: State, transcript: Transcript):\n    # state: JSON file per session, auto-loaded\n    count = state.get(\"bash_count\", 0) + 1\n    state[\"bash_count\"] = count\n    state.save()\n\n    # transcript: Parsed conversation history with stats\n    if transcript.stats.tool_calls.get(\"Bash\", 0) &gt; 100:\n        return deny(\"Rate limit exceeded\")\n</code></pre> <p>Pros: Zero setup, injected automatically, no external services Cons: Simpler storage (JSON), no vector search built-in</p>"},{"location":"comparison/claude-mem/#hook-registration","title":"Hook Registration","text":""},{"location":"comparison/claude-mem/#claude-mem-monolithic-json","title":"claude-mem: Monolithic JSON","text":"<pre><code>{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"startup|clear|compact\",\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"node smart-install.js\", \"timeout\": 300 },\n          { \"type\": \"command\", \"command\": \"bun worker-service.cjs start\", \"timeout\": 15 },\n          { \"type\": \"command\", \"command\": \"node context-hook.js\", \"timeout\": 15 }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"node save-hook.js\", \"timeout\": 300 }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>Single JSON file, multiple commands per event, sequential execution.</p>"},{"location":"comparison/claude-mem/#fasthooks-decorators-blueprints","title":"fasthooks: Decorators + Blueprints","text":"<pre><code>from fasthooks import HookApp, Blueprint\n\n# Main app\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    ...\n\n# Modular blueprints\nsecurity = Blueprint()\n\n@security.pre_tool(\"Write\")\ndef check_write(event):\n    ...\n\napp.include(security)\n</code></pre> <p>Decorator-based registration, composable blueprints, guards for filtering.</p>"},{"location":"comparison/claude-mem/#error-handling","title":"Error Handling","text":""},{"location":"comparison/claude-mem/#claude-mem-throw-log","title":"claude-mem: Throw &amp; Log","text":"<pre><code>async function saveHook(input?: PostToolUseInput): Promise&lt;void&gt; {\n  if (!input) {\n    throw new Error('saveHook requires input');  // Process exits with code 1\n  }\n\n  const response = await fetch(...);\n  if (!response.ok) {\n    throw new Error(`Observation storage failed: ${response.status}`);\n  }\n\n  console.log(STANDARD_HOOK_RESPONSE);\n}\n</code></pre> <p>Errors propagate, logged to file, Claude continues (graceful degradation).</p>"},{"location":"comparison/claude-mem/#fasthooks-structured-responses","title":"fasthooks: Structured Responses","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef handler(event):\n    try:\n        validate_command(event.command)\n    except SecurityError as e:\n        return deny(str(e))  # Structured denial\n    return allow()\n</code></pre> <p>Errors become structured responses that Claude understands.</p>"},{"location":"comparison/claude-mem/#testing","title":"Testing","text":""},{"location":"comparison/claude-mem/#claude-mem-integration-tests","title":"claude-mem: Integration Tests","text":"<pre><code>// Spawn real hook processes, check JSON output\nfunction runHookScript(scriptName: string, input: object): string {\n  const result = execSync(`bash \"${scriptPath}\"`, {\n    input: JSON.stringify(input),\n  });\n  return result.toString('utf-8');\n}\n\nit('should output valid JSON', () =&gt; {\n  const output = runHookScript('session-init.sh', { ... });\n  expect(() =&gt; JSON.parse(output)).not.toThrow();\n});\n</code></pre> <p>No mocking utilities - tests spawn real processes.</p>"},{"location":"comparison/claude-mem/#fasthooks-mockevent-testclient","title":"fasthooks: MockEvent + TestClient","text":"<pre><code>from fasthooks.testing import MockEvent, TestClient\n\ndef test_blocks_dangerous_commands():\n    app = HookApp()\n\n    @app.pre_tool(\"Bash\")\n    def handler(event):\n        if \"rm -rf\" in event.command:\n            return deny(\"Blocked\")\n\n    client = TestClient(app)\n\n    # Mock events without spawning processes\n    response = client.send(MockEvent.bash(command=\"rm -rf /\"))\n    assert response.decision == \"deny\"\n\n    response = client.send(MockEvent.bash(command=\"ls\"))\n    assert response is None  # Allowed\n</code></pre> <p>First-class testing utilities with mock events.</p>"},{"location":"comparison/claude-mem/#feature-matrix","title":"Feature Matrix","text":"Feature claude-mem fasthooks Hook Framework \u274c (app, not framework) \u2705 Deny/Block \u274c \u2705 Typed Events Partial (interfaces) \u2705 (Pydantic) Property Accessors \u274c \u2705 (<code>event.command</code>) State Persistence \u2705 (SQLite) \u2705 (JSON) Transcript Parsing \u2705 (via SDK) \u2705 (built-in) Vector Search \u2705 (Chroma) \u274c Background Tasks \u2705 (SDK agent) \u2705 (<code>Tasks</code>) Blueprints \u274c \u2705 Middleware \u274c \u2705 Guards \u274c \u2705 (<code>when=</code>) Testing Utils \u274c \u2705 Web UI \u2705 \u274c Memory/RAG \u2705 (core feature) \u274c"},{"location":"comparison/claude-mem/#when-to-use-each","title":"When to Use Each","text":""},{"location":"comparison/claude-mem/#use-claude-mem-when","title":"Use claude-mem When:","text":"<ul> <li>You want persistent memory across Claude Code sessions</li> <li>You need semantic search over past conversations</li> <li>You want a ready-to-use solution (not building custom hooks)</li> <li>You're okay with running a background service</li> <li>You don't need to block or modify Claude's actions</li> </ul>"},{"location":"comparison/claude-mem/#use-fasthooks-when","title":"Use fasthooks When:","text":"<ul> <li>You're building custom hooks with specific logic</li> <li>You need to enforce policies (deny dangerous commands, rate limit)</li> <li>You want typed events with IDE autocomplete</li> <li>You need modular composition (blueprints, middleware)</li> <li>You want easy testing with mock events</li> <li>You prefer self-contained hooks (no external services)</li> </ul>"},{"location":"comparison/claude-mem/#using-both-together","title":"Using Both Together","text":"<p>claude-mem and fasthooks serve different purposes and can coexist:</p> <pre><code>{\n  \"hooks\": {\n    \"PreToolUse\": [\n      { \"command\": \"python /path/to/fasthooks/security.py\" }\n    ],\n    \"PostToolUse\": [\n      { \"command\": \"python /path/to/fasthooks/audit.py\" },\n      { \"command\": \"node /path/to/claude-mem/save-hook.js\" }\n    ],\n    \"SessionStart\": [\n      { \"command\": \"node /path/to/claude-mem/context-hook.js\" }\n    ]\n  }\n}\n</code></pre> <ul> <li>fasthooks for PreToolUse enforcement (block dangerous commands)</li> <li>claude-mem for PostToolUse observation (capture what happened)</li> <li>Both can run on the same events (sequential execution)</li> </ul>"},{"location":"comparison/claude-mem/#summary","title":"Summary","text":"Aspect claude-mem fasthooks What It Is Memory plugin Hook framework Philosophy Observe &amp; remember Validate &amp; control Best For Persistent context Custom hook logic Complexity Full application Library Dependencies Worker service, Bun, SQLite, Chroma None (pure Python)"},{"location":"comparison/continuous-claude/","title":"Continuous-Claude-v2 vs fasthooks","text":"<p>Continuous-Claude-v2 is a session continuity system that preserves context across Claude Code sessions. This page compares its hook implementation with fasthooks.</p>"},{"location":"comparison/continuous-claude/#different-goals","title":"Different Goals","text":"Aspect Continuous-Claude-v2 fasthooks Primary Purpose Session continuity Hook development framework Philosophy Preserve state across clears Build custom hook logic Core Feature Ledgers + handoffs Typed events + DI Target User Power users wanting continuity Developers building hooks <p>Continuous-Claude-v2 solves context degradation - when Claude compacts, you lose signal. Instead of fighting compaction, it embraces <code>/clear</code> with preserved state via ledgers and handoffs.</p> <p>fasthooks is a framework for building any hook logic - security policies, rate limiting, code review, integrations.</p>"},{"location":"comparison/continuous-claude/#architecture-comparison","title":"Architecture Comparison","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2-pre-bundled-typescript","title":"Continuous-Claude-v2: Pre-bundled TypeScript","text":"<pre><code>.claude/hooks/\n\u251c\u2500\u2500 src/                    # TypeScript source\n\u2502   \u251c\u2500\u2500 session-start-continuity.ts\n\u2502   \u251c\u2500\u2500 typescript-preflight.ts\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 dist/                   # Pre-compiled JS (committed)\n\u2502   \u251c\u2500\u2500 session-start-continuity.mjs\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 *.sh                    # Shell wrappers\n\u2502   \u251c\u2500\u2500 session-start.sh    \u2192 node dist/session-start-continuity.mjs\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 build.sh                # Rebuild after source changes\n</code></pre> <p>Deployment: Copy <code>.claude/hooks/</code>, make scripts executable. No npm install needed.</p>"},{"location":"comparison/continuous-claude/#fasthooks-pure-python","title":"fasthooks: Pure Python","text":"<pre><code># hooks.py\nfrom fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Blocked\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Deployment: <code>pip install fasthooks</code>, point Claude Code to <code>python hooks.py</code>.</p>"},{"location":"comparison/continuous-claude/#hook-events-supported","title":"Hook Events Supported","text":"Event Continuous-Claude fasthooks SessionStart \u2705 \u2705 PreToolUse \u2705 \u2705 PostToolUse \u2705 \u2705 PreCompact \u2705 \u2705 UserPromptSubmit \u2705 \u2705 SubagentStop \u2705 \u2705 SessionEnd \u2705 \u2705 Stop \u274c \u2705 Notification \u274c \u2705 PermissionRequest \u274c \u2705 <p>Both cover core events. fasthooks has broader coverage.</p>"},{"location":"comparison/continuous-claude/#response-format","title":"Response Format","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2-manual-json","title":"Continuous-Claude-v2: Manual JSON","text":"<pre><code>// Block decision (PreToolUse only)\nconsole.log(JSON.stringify({\n  decision: 'block',\n  reason: 'TypeScript errors found:\\n  Line 15: Property does not exist'\n}));\n\n// Context injection\nconsole.log(JSON.stringify({\n  result: 'continue',\n  hookSpecificOutput: {\n    hookEventName: 'SessionStart',\n    additionalContext: ledgerContent + '\\n\\n' + handoffContent\n  }\n}));\n\n// Simple continue\nconsole.log(JSON.stringify({ continue: true }));\n</code></pre>"},{"location":"comparison/continuous-claude/#fasthooks-helper-functions","title":"fasthooks: Helper Functions","text":"<pre><code>from fasthooks import allow, deny, block\n\n@app.pre_tool(\"Bash\")\ndef check(event):\n    if dangerous(event.command):\n        return deny(\"Blocked\")        # Block with reason\n    return allow(message=\"Approved\")  # Continue with message\n\n@app.on_stop()\ndef prevent_stop(event):\n    return block(\"Keep working\")      # Prevent stopping\n</code></pre> Aspect Continuous-Claude fasthooks Block tool <code>decision: 'block'</code> <code>deny(\"reason\")</code> Allow <code>continue: true</code> <code>allow()</code> or <code>None</code> Inject context <code>hookSpecificOutput.additionalContext</code> <code>allow(message=...)</code> Block stop Not supported <code>block(\"reason\")</code>"},{"location":"comparison/continuous-claude/#blocking-capability","title":"Blocking Capability","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2-pretooluse-only","title":"Continuous-Claude-v2: PreToolUse Only","text":"<pre><code>// typescript-preflight.ts - blocks on type errors\nif (checkResult.has_errors) {\n  console.log(JSON.stringify({\n    decision: 'block',\n    reason: `\u26a0\ufe0f TypeScript Pre-flight: ${checkResult.summary}`\n  }));\n  return;\n}\n</code></pre> <p>Only PreToolUse can block. Other events just continue or inject context.</p>"},{"location":"comparison/continuous-claude/#fasthooks-any-event","title":"fasthooks: Any Event","text":"<pre><code>@app.pre_tool(\"Write\")\ndef check_write(event):\n    if \".env\" in event.file_path:\n        return deny(\"Cannot modify .env\")\n\n@app.on_stop()\ndef require_tests(event, transcript: Transcript):\n    if transcript.stats.tool_calls.get(\"Bash\", 0) == 0:\n        return block(\"Run tests before stopping\")\n\n@app.on_prompt()\ndef rate_limit(event, state: State):\n    if state.get(\"prompts\", 0) &gt; 100:\n        return deny(\"Rate limit exceeded\")\n</code></pre> <p>Any handler can deny/block, not just PreToolUse.</p>"},{"location":"comparison/continuous-claude/#state-management","title":"State Management","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2-three-layer-system","title":"Continuous-Claude-v2: Three-Layer System","text":"<p>Layer 1: Continuity Ledger (within-session) <pre><code>&lt;!-- thoughts/ledgers/CONTINUITY_CLAUDE-myproject.md --&gt;\n## Goal\nImplement payment integration\n\n## State\n- Done: Auth system \u2713\n- Now: Payment webhooks\n- Next: Stripe sandbox tests\n</code></pre></p> <p>Layer 2: Handoffs (between-session) <pre><code>&lt;!-- thoughts/shared/handoffs/session-123/task-1.md --&gt;\n---\nroot_span_id: abc-123\noutcome: PARTIAL_PLUS\n---\n## Context\nWorking on payment webhooks...\n\n## Key Decisions\n- Using Stripe webhooks over polling\n</code></pre></p> <p>Layer 3: Artifact Index (searchable history) <pre><code>-- .claude/cache/artifact-index/context.db (SQLite + FTS5)\nSELECT * FROM handoffs\nWHERE outcome = 'FAILED'\nAND what_failed LIKE '%authentication%'\n</code></pre></p>"},{"location":"comparison/continuous-claude/#fasthooks-dependency-injection","title":"fasthooks: Dependency Injection","text":"<pre><code>from fasthooks.depends import State, Transcript\n\n@app.pre_tool(\"Bash\")\ndef handler(event, state: State, transcript: Transcript):\n    # state: JSON file per session, auto-loaded\n    state[\"command_count\"] = state.get(\"command_count\", 0) + 1\n    state.save()\n\n    # transcript: Parsed history with stats\n    print(f\"Total tokens: {transcript.stats.total_tokens}\")\n</code></pre> Aspect Continuous-Claude fasthooks State format Markdown ledgers JSON dict Persistence File-based (3 layers) File-based (1 layer) Searchable SQLite + FTS5 No built-in search Complexity High (rich context) Low (simple state) Setup Requires directory structure Zero setup"},{"location":"comparison/continuous-claude/#unique-features","title":"Unique Features","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2","title":"Continuous-Claude-v2","text":"<p>1. TypeScript Preflight <pre><code>// PreToolUse runs tsc --noEmit before Edit/Write on .ts files\nif (checkResult.has_errors) {\n  return { decision: 'block', reason: errorSummary };\n}\n</code></pre> Catches type errors before they're written.</p> <p>2. Skill Auto-Activation <pre><code>// skill-rules.json\n{\n  \"skills\": {\n    \"morph-search\": {\n      \"priority\": \"high\",\n      \"promptTriggers\": {\n        \"keywords\": [\"search\", \"grep\", \"find\"]\n      }\n    }\n  }\n}\n</code></pre> UserPromptSubmit hook suggests skills based on keywords/intent.</p> <p>3. Auto-Handoff on Compact</p> <p>PreCompact hook automatically: 1. Parses transcript 2. Generates handoff with file:line references 3. SessionStart loads it on resume</p> <p>No manual handoff needed.</p> <p>4. Outcome Tracking <pre><code>SUCCEEDED | PARTIAL_PLUS | PARTIAL_MINUS | FAILED\n</code></pre> Mark handoff outcomes, query past failures to improve decisions.</p> <p>5. Context Percentage Warnings</p> <p>Reads <code>/tmp/claude-context-pct-{SESSION}.txt</code>, shows warnings: - &lt;60%: Normal - 60-79%: Yellow warning - 80%+: Red critical</p> <p>6. Pre-bundled Deployment</p> <p>No npm install - just copy <code>.claude/hooks/</code> and run.</p>"},{"location":"comparison/continuous-claude/#fasthooks","title":"fasthooks","text":"<p>1. Response Helpers <pre><code>deny(\"reason\")   # Block with message\nblock(\"reason\")  # Prevent stop\nallow(message=\"...\") # Continue with feedback\n</code></pre></p> <p>2. Dependency Injection <pre><code>def handler(event, state: State, transcript: Transcript, tasks: Tasks):\n    # All dependencies auto-injected\n</code></pre></p> <p>3. Blueprints <pre><code>security = Blueprint()\n\n@security.pre_tool(\"Bash\")\ndef no_sudo(event):\n    ...\n\napp.include(security)\n</code></pre></p> <p>4. Guards <pre><code>@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)\ndef check_sudo(event):\n    return deny(\"No sudo\")\n</code></pre></p> <p>5. Background Tasks <pre><code>@task\ndef analyze(code: str) -&gt; str:\n    return expensive_analysis(code)\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(analyze, event.content)\n</code></pre></p> <p>6. Testing Utilities <pre><code>client = TestClient(app)\nresponse = client.send(MockEvent.bash(command=\"rm -rf /\"))\nassert response.decision == \"deny\"\n</code></pre></p>"},{"location":"comparison/continuous-claude/#developer-experience","title":"Developer Experience","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2-typescript-shell","title":"Continuous-Claude-v2: TypeScript + Shell","text":"<pre><code>// .claude/hooks/src/my-hook.ts\nimport { readFileSync } from 'fs';\n\ninterface Input {\n  session_id: string;\n  cwd: string;\n  tool_name: string;\n  tool_input: any;\n}\n\nconst input: Input = JSON.parse(readFileSync('/dev/stdin', 'utf-8'));\n\nif (input.tool_name === 'Bash' &amp;&amp; input.tool_input.command.includes('rm')) {\n  console.log(JSON.stringify({ decision: 'block', reason: 'Blocked' }));\n} else {\n  console.log(JSON.stringify({ continue: true }));\n}\n</code></pre> <pre><code># .claude/hooks/my-hook.sh\n#!/bin/bash\ncd ~/.claude/hooks\ncat | node dist/my-hook.mjs\n</code></pre> <p>Workflow: 1. Edit TypeScript in <code>src/</code> 2. Run <code>./build.sh</code> to compile 3. Test by running hook manually 4. Commit <code>dist/</code> for deployment</p>"},{"location":"comparison/continuous-claude/#fasthooks-pure-python_1","title":"fasthooks: Pure Python","text":"<pre><code># hooks.py\nfrom fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm\" in event.command:\n        return deny(\"Blocked\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Workflow: 1. Write Python 2. Run tests with <code>TestClient</code> 3. Deploy</p>"},{"location":"comparison/continuous-claude/#feature-matrix","title":"Feature Matrix","text":"Feature Continuous-Claude fasthooks Hook Framework Partial (specialized) \u2705 (general purpose) Deny/Block PreToolUse only Any event Typed Events TypeScript interfaces Pydantic models Property Accessors Manual (<code>input.tool_input.x</code>) <code>event.command</code> State Persistence \u2705 (3-layer) \u2705 (simple) Transcript Parsing \u2705 (for handoffs) \u2705 (built-in) Background Tasks \u274c \u2705 Blueprints \u274c \u2705 Middleware \u274c \u2705 Guards \u274c \u2705 Testing Utils \u274c \u2705 Skills System \u2705 \u274c TypeScript Preflight \u2705 \u274c Auto-Handoff \u2705 \u274c Outcome Tracking \u2705 \u274c Zero-Config Deploy \u2705 (pre-bundled) Requires pip"},{"location":"comparison/continuous-claude/#when-to-use-each","title":"When to Use Each","text":""},{"location":"comparison/continuous-claude/#use-continuous-claude-v2-when","title":"Use Continuous-Claude-v2 When:","text":"<ul> <li>You want session continuity across <code>/clear</code> and compaction</li> <li>You need ledgers and handoffs for complex multi-session work</li> <li>You want TypeScript type checking before edits</li> <li>You need skill auto-activation based on keywords</li> <li>You want outcome tracking to learn from past sessions</li> <li>You prefer pre-bundled deployment (no pip/npm at runtime)</li> </ul>"},{"location":"comparison/continuous-claude/#use-fasthooks-when","title":"Use fasthooks When:","text":"<ul> <li>You're building custom hooks with any logic</li> <li>You need to block on any event (not just PreToolUse)</li> <li>You want typed events with IDE autocomplete</li> <li>You need dependency injection (State, Transcript, Tasks)</li> <li>You want modular composition (blueprints, middleware)</li> <li>You need easy testing with mock events</li> <li>You want background tasks for async work</li> </ul>"},{"location":"comparison/continuous-claude/#using-both-together","title":"Using Both Together","text":"<p>The systems serve different purposes and can coexist:</p> <pre><code>{\n  \"hooks\": {\n    \"SessionStart\": [\n      { \"command\": \"~/.claude/hooks/session-start.sh\" }\n    ],\n    \"PreToolUse\": [\n      { \"command\": \"python /path/to/fasthooks/security.py\" },\n      { \"command\": \"~/.claude/hooks/typescript-preflight.sh\" }\n    ],\n    \"PostToolUse\": [\n      { \"command\": \"~/.claude/hooks/handoff-index.sh\" }\n    ],\n    \"PreCompact\": [\n      { \"command\": \"~/.claude/hooks/pre-compact.sh\" }\n    ]\n  }\n}\n</code></pre> <ul> <li>Continuous-Claude for session continuity (ledgers, handoffs, context injection)</li> <li>fasthooks for policy enforcement (security, rate limiting, custom logic)</li> </ul>"},{"location":"comparison/continuous-claude/#summary","title":"Summary","text":"Aspect Continuous-Claude-v2 fasthooks What It Is Session continuity system Hook framework Philosophy Preserve context across clears Build custom hook logic Best For Long-running projects Custom policies Language TypeScript + Shell Python Blocking PreToolUse only Any event Complexity High (rich features) Low (simple API) Dependencies Pre-bundled (none) pip install"},{"location":"strategies/","title":"Strategies","text":""},{"location":"strategies/#raw-hooks-vs-strategy-when-to-use-which","title":"Raw Hooks vs Strategy: When to Use Which","text":"<p>Raw fasthooks and Strategy can both accomplish the same things. The difference is in packaging and reuse.</p>"},{"location":"strategies/#use-raw-hooks-when","title":"Use Raw Hooks When:","text":"<ul> <li>Building project-specific hooks</li> <li>Simple logic (1-2 hooks, minimal state)</li> <li>You want maximum transparency</li> <li>Learning how fasthooks works</li> </ul> <pre><code># Raw fasthooks - simple, transparent, project-specific\nfrom fasthooks import HookApp, deny\nfrom fasthooks.depends import State\n\napp = HookApp(state_dir=\"/tmp/hook-state\")\n\n@app.pre_tool(\"Bash\")\ndef rate_limit(event, state: State):\n    count = state.get(\"bash_count\", 0) + 1\n    state[\"bash_count\"] = count\n    state.save()\n    if count &gt; 100:\n        return deny(f\"Rate limit: {count}/100 commands\")\n</code></pre>"},{"location":"strategies/#use-strategy-when","title":"Use Strategy When:","text":"<ul> <li>Reusing a proven pattern - don't reinvent complex logic</li> <li>Distributing hooks - share via PyPI packages</li> <li>Multiple strategies coexisting - namespace isolation prevents state collisions</li> <li>Debugging complex behavior - built-in observability</li> </ul> <pre><code># Strategy - packaged, configurable, reusable\nfrom fasthooks import HookApp\nfrom fasthooks.strategies import LongRunningStrategy\n\napp = HookApp()\n\nstrategy = LongRunningStrategy(\n    feature_list=\"features.json\",\n    enforce_commits=True,\n)\napp.include(strategy.get_blueprint())\n</code></pre>"},{"location":"strategies/#what-strategy-adds","title":"What Strategy Adds","text":"<p>Raw fasthooks already provides state, multiple hooks, and complex logic. Strategy adds a packaging layer:</p> Feature Raw Hooks Strategy State persistence <code>state: State</code> DI Same, plus auto-namespacing Multiple hooks Register each manually Bundle as single unit Configuration Hardcoded or manual Kwargs with validation Observability Manual logging Built-in events Distribution Copy-paste code PyPI packages Conflict detection None Meta.hooks declaration Testing TestClient StrategyTestClient with helpers"},{"location":"strategies/#state-namespace-isolation","title":"State Namespace Isolation","text":"<p>When multiple strategies run together, each gets isolated state:</p> <pre><code># Strategy A writes to state['strategy-a']['key']\n# Strategy B writes to state['strategy-b']['key']\n# No collision possible\n</code></pre> <p>With raw hooks, you'd manage this manually.</p>"},{"location":"strategies/#when-strategy-truly-shines","title":"When Strategy Truly Shines","text":"<p>Consider <code>LongRunningStrategy</code> - Anthropic's two-agent pattern for autonomous agents:</p> <ul> <li>5 hooks coordinating: session_start, stop, pre_compact, post_tool:Write, post_tool:Bash</li> <li>State tracked across hooks: session count, files modified, commits made, progress updated</li> <li>Complex logic: mode detection (initializer vs coding), feature list validation, git status checks</li> <li>Hard to get right: timing, edge cases, state management</li> </ul> <p>You could build this with raw fasthooks. But you'd be reimplementing 500+ lines of tested logic.</p> <pre><code># Without Strategy - you write and maintain all this yourself\n@app.on_session_start()\ndef handle_session_start(event, state: State):\n    # 50 lines of mode detection, context injection...\n\n@app.on_stop()\ndef handle_stop(event, state: State):\n    # 40 lines of commit enforcement, progress checks...\n\n@app.on_pre_compact()\ndef handle_pre_compact(event, state: State, transcript: Transcript):\n    # 20 lines of checkpoint warnings...\n\n@app.post_tool(\"Write\")\ndef track_write(event, state: State):\n    # 30 lines of file tracking, feature list validation...\n\n@app.post_tool(\"Bash\")\ndef track_bash(event, state: State):\n    # 15 lines of commit tracking...\n\n# Plus helper functions, error handling, edge cases...\n</code></pre> <pre><code># With Strategy - use proven implementation\nstrategy = LongRunningStrategy(enforce_commits=True)\napp.include(strategy.get_blueprint())\n</code></pre> <p>Strategy packages complex patterns so you don't reinvent them.</p>"},{"location":"strategies/#built-in-strategies","title":"Built-in Strategies","text":"Strategy Purpose Complexity LongRunningStrategy Two-agent pattern for autonomous agents High (5 hooks, state, modes) TokenBudgetStrategy Warn on token usage thresholds Low (1 hook) CleanStateStrategy Enforce clean state before stopping Low (1 hook)"},{"location":"strategies/#simple-strategies-educational-value","title":"Simple Strategies: Educational Value","text":"<p><code>TokenBudgetStrategy</code> and <code>CleanStateStrategy</code> are simple enough to implement with raw hooks:</p> <pre><code># TokenBudgetStrategy as raw hooks (~10 lines)\n@app.post_tool()\ndef check_tokens(event, transcript: Transcript):\n    total = transcript.stats.input_tokens + transcript.stats.output_tokens\n    if total &gt;= 150_000:\n        return allow(message=\"\u26a0\ufe0f Token limit approaching!\")\n</code></pre> <pre><code># CleanStateStrategy as raw hooks (~15 lines)\n@app.on_stop()\ndef enforce_clean(event):\n    result = subprocess.run([\"git\", \"status\", \"--porcelain\"],\n                            capture_output=True, text=True, cwd=event.cwd)\n    if result.stdout.strip():\n        return block(\"Uncommitted changes exist\")\n</code></pre> <p>We provide them as built-in strategies to:</p> <ol> <li>Demonstrate the pattern - see how Strategy wraps simple logic</li> <li>Provide starting points - extend them for your needs</li> <li>Show the spectrum - from simple (1 hook) to complex (5 hooks)</li> </ol> <p>For simple cases, raw hooks are often cleaner. As complexity grows, Strategy pays off.</p>"},{"location":"strategies/#quick-comparison","title":"Quick Comparison","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Your Decision Tree                                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                              \u2502\n\u2502  Is this a one-off, project-specific hook?                   \u2502\n\u2502    YES \u2192 Use raw fasthooks                                   \u2502\n\u2502                                                              \u2502\n\u2502  Are you implementing a complex, multi-hook pattern?         \u2502\n\u2502    YES \u2192 Check if a Strategy exists first                    \u2502\n\u2502                                                              \u2502\n\u2502  Do you want to share/distribute this pattern?               \u2502\n\u2502    YES \u2192 Create a Strategy, publish to PyPI                  \u2502\n\u2502                                                              \u2502\n\u2502  Do you need observability/debugging?                        \u2502\n\u2502    YES \u2192 Strategy has it built-in                            \u2502\n\u2502                                                              \u2502\n\u2502  Are multiple patterns running together?                     \u2502\n\u2502    YES \u2192 Strategy namespacing prevents collisions            \u2502\n\u2502                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"strategies/#creating-a-strategy","title":"Creating a Strategy","text":"<p>Extend the <code>Strategy</code> base class:</p> <pre><code>from fasthooks import Blueprint, deny\nfrom fasthooks.strategies import Strategy\n\nclass MyStrategy(Strategy):\n    class Meta:\n        name = \"my-strategy\"\n        version = \"1.0.0\"\n        description = \"Does something useful\"\n        hooks = [\"pre_tool:Bash\"]\n\n    def __init__(self, *, blocked_commands: list[str] | None = None):\n        # IMPORTANT: Set attributes BEFORE super().__init__()\n        # super().__init__() calls _validate_config() which may need these\n        self.blocked_commands = blocked_commands or [\"rm -rf\"]\n        super().__init__()\n\n    def _build_blueprint(self) -&gt; Blueprint:\n        bp = Blueprint(\"my-strategy\")\n\n        @bp.pre_tool(\"Bash\")\n        def check_bash(event):\n            for cmd in self.blocked_commands:\n                if cmd in event.command:\n                    return deny(f\"Blocked: {cmd}\")\n\n        return bp\n</code></pre>"},{"location":"strategies/#meta-class-options","title":"Meta Class Options","text":"Field Required Description <code>name</code> Yes Unique identifier (used for state namespace, conflict detection) <code>version</code> Yes Semantic version string <code>hooks</code> Yes List of hooks this strategy uses (for conflict detection) <code>description</code> No Human-readable description <code>fail_mode</code> No <code>\"open\"</code> or <code>\"closed\"</code> - metadata only (errors currently raise) <code>custom_events</code> No List of custom event types this strategy emits <code>state_namespace</code> No Override state namespace (defaults to strategy name) <p>Hook format: <code>\"on_stop\"</code>, <code>\"pre_tool:Bash\"</code>, <code>\"post_tool:*\"</code> (catch-all).</p>"},{"location":"strategies/#validation","title":"Validation","text":"<p>Override <code>_validate_config()</code> for custom validation:</p> <pre><code>def _validate_config(self) -&gt; None:\n    if self.max_retries &lt; 0:\n        raise ValueError(\"max_retries must be non-negative\")\n</code></pre> <p>Called automatically by <code>super().__init__()</code>.</p>"},{"location":"strategies/#using-dependencies","title":"Using Dependencies","text":"<p>Handlers can use DI just like raw hooks:</p> <pre><code>from fasthooks.depends import State, Transcript\n\ndef _build_blueprint(self) -&gt; Blueprint:\n    bp = Blueprint(\"my-strategy\")\n\n    @bp.post_tool()\n    def track_usage(event, state: State, transcript: Transcript):\n        # State is auto-namespaced to strategy name\n        state[\"call_count\"] = state.get(\"call_count\", 0) + 1\n        state.save()\n\n        # Transcript provides token stats\n        total = transcript.stats.input_tokens + transcript.stats.output_tokens\n        if total &gt; 100_000:\n            return allow(message=\"Token warning!\")\n\n    return bp\n</code></pre>"},{"location":"strategies/#testing","title":"Testing","text":"<p>Use <code>StrategyTestClient</code>:</p> <pre><code>from fasthooks.testing import StrategyTestClient\nfrom fasthooks.strategies import LongRunningStrategy\n\ndef test_blocks_on_uncommitted_changes():\n    strategy = LongRunningStrategy(enforce_commits=True)\n    client = StrategyTestClient(strategy)\n\n    # Set up git with uncommitted changes\n    client.setup_git()\n    client.add_uncommitted(\"dirty.py\")\n\n    # Trigger stop hook\n    client.trigger_session_start()  # Initialize state\n    response = client.trigger_stop()\n\n    assert response is not None\n    client.assert_blocked(\"uncommitted\")\n</code></pre> <p>For strategies using <code>Transcript</code>:</p> <pre><code>from unittest.mock import Mock\n\ndef test_with_transcript():\n    client = StrategyTestClient(strategy)\n\n    # Mock transcript with token counts\n    mock_transcript = Mock()\n    mock_transcript.stats.input_tokens = 100_000\n    mock_transcript.stats.output_tokens = 50_000\n    client.set_transcript(mock_transcript)\n\n    response = client.trigger_post_bash(command=\"echo test\")\n    # ...\n</code></pre>"},{"location":"strategies/#observability","title":"Observability","text":"<p>All strategies emit events automatically:</p> <pre><code>strategy = LongRunningStrategy()\n\n@strategy.on_observe\ndef log_events(event):\n    print(f\"[{event.event_type}] {event.hook_name}\")\n\napp.include(strategy.get_blueprint())\n</code></pre> <p>Events emitted: - <code>hook_enter</code> - Handler starts - <code>hook_exit</code> - Handler ends (with duration) - <code>decision</code> - Handler returns allow/deny/block - <code>error</code> - Handler throws exception - <code>custom</code> - Strategy-specific events</p>"},{"location":"strategies/#future-work","title":"Future Work","text":"<p>The following features are planned but not yet implemented:</p> <ul> <li>App-level observability (<code>@app.on_observe</code>) - Single callback for all strategy events</li> <li>fail_mode enforcement - Currently metadata-only; handler errors raise exceptions</li> </ul>"},{"location":"strategies/#further-reading","title":"Further Reading","text":"<ul> <li>Long-Running Strategy Guide</li> <li>Live Example: Expense Tracker built with LongRunningStrategy</li> <li>Testing Strategies</li> </ul>"},{"location":"strategies/long-running/","title":"Long-Running Agent Strategy","text":"<p>The <code>LongRunningStrategy</code> implements Anthropic's two-agent pattern for autonomous agents that work across multiple context windows. It prevents the two common failure modes of long-running agents: one-shotting (trying to do everything at once) and premature victory (declaring done too early).</p> <p>Live Example: See a full expense tracker app built autonomously using this strategy: github.com/oneryalcin/fasthooks_example_longrun</p> <p>The repo includes the hooks configuration, Docker setup, and the complete 24-feature app with session history.</p>"},{"location":"strategies/long-running/#the-problem","title":"The Problem","text":"<p>Long-running autonomous agents face a fundamental challenge: they work in discrete sessions, and each new session starts with no memory of what came before. This leads to:</p> <ol> <li>One-shotting: Agent attempts to implement entire project at once, runs out of context mid-implementation, leaves broken state</li> <li>Premature victory: Agent sees some progress and declares the project complete despite many features remaining</li> </ol>"},{"location":"strategies/long-running/#the-solution-two-agent-pattern","title":"The Solution: Two-Agent Pattern","text":"<p>The strategy injects different context for first vs. subsequent sessions:</p> Session Role Context Injected First Initializer \"Create <code>feature_list.json</code>, <code>init.sh</code>, git repo\" Subsequent Coding \"Read progress, work on ONE feature, commit\" <pre><code>Session 1 (Initializer)          Sessions 2+ (Coding)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Create feature_list \u2502          \u2502 Read progress file  \u2502\n\u2502 (30+ features)      \u2502          \u2502 Verify existing     \u2502\n\u2502                     \u2502          \u2502 Pick ONE feature    \u2502\n\u2502 Create init.sh      \u2502          \u2502 Implement &amp; test    \u2502\n\u2502 Initialize git      \u2502          \u2502 Mark passes: true   \u2502\n\u2502 First commit        \u2502          \u2502 Commit &amp; update     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"strategies/long-running/#understanding-two-agents","title":"Understanding \"Two Agents\"","text":"<p>Important: The \"two agents\" are NOT two separate systems\u2014they're the same Claude with different context injected based on project state. The term \"agent\" refers to the role Claude plays.</p>"},{"location":"strategies/long-running/#architecture-anthropic-vs-fasthooks","title":"Architecture: Anthropic vs fasthooks","text":"<p>This strategy implements Anthropic's pattern from their original article, but uses Claude Code hooks instead of a Python script loop.</p>"},{"location":"strategies/long-running/#anthropics-original-approach","title":"Anthropic's Original Approach","text":"<pre><code># Python script acts as the outer loop\nwhile True:\n    client = create_claude_client()  # Fresh context each iteration\n\n    if not feature_list_exists():\n        prompt = INITIALIZER_PROMPT\n    else:\n        prompt = CODING_PROMPT\n\n    await client.query(prompt)\n    # Script manages continuation\n</code></pre>"},{"location":"strategies/long-running/#fasthooks-approach-hooks-based","title":"fasthooks Approach (Hooks-Based)","text":"<pre><code># Hooks inject context into Claude Code's lifecycle\n@app.on_session_start()\ndef on_session_start(event, state):\n    if not feature_list_exists():\n        return context(INITIALIZER_PROMPT)\n    else:\n        return context(CODING_PROMPT)\n\n@app.on_stop()\ndef on_stop(event, state):\n    if not clean_state():\n        return block(\"Commit and update progress first\")\n</code></pre>"},{"location":"strategies/long-running/#comparison","title":"Comparison","text":"Aspect Anthropic (Script) fasthooks (Hooks) Outer loop Python <code>while True</code> Claude Code's session lifecycle Fresh context Script creates new client Claude Code compaction triggers SessionStart Context injection Pass prompt to client Hook returns <code>context(...)</code> Enforce clean state Prompt instructions only Hook blocks Stop until clean Browser testing Puppeteer MCP chrome-devtools MCP (headless) <p>Key advantage of hooks: The <code>on_stop</code> hook can enforce clean state by blocking, while Anthropic's script relies on prompt instructions alone.</p>"},{"location":"strategies/long-running/#quick-start","title":"Quick Start","text":""},{"location":"strategies/long-running/#1-create-your-hooks-file","title":"1. Create Your Hooks File","text":"<p>Create <code>hooks/main.py</code> (outside your project workspace):</p> <pre><code>#!/usr/bin/env python3\nfrom fasthooks import HookApp\nfrom fasthooks.strategies import LongRunningStrategy\n\napp = HookApp(\n    log_dir=\"/opt/hooks/logs\",    # Outside workspace\n    state_dir=\"/opt/hooks/logs\",  # Outside workspace\n)\n\nstrategy = LongRunningStrategy(\n    min_features=5,  # Adjust for your project\n)\n\n# Optional: Enable observability logging\n@strategy.on_observe\ndef log_events(event):\n    with open(\"/opt/hooks/logs/strategy.log\", \"a\") as f:\n        f.write(f\"[{event.timestamp}] {event.event_type}: {event.hook_name}\\n\")\n\napp.include(strategy.get_blueprint())\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"strategies/long-running/#2-configure-claude-code-settings","title":"2. Configure Claude Code Settings","text":"<p>Add to your Claude Code settings (<code>~/.claude/settings.json</code>):</p> <pre><code>{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [{\"type\": \"command\", \"command\": \"python3 /opt/hooks/main.py\"}]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [{\"type\": \"command\", \"command\": \"python3 /opt/hooks/main.py\"}]\n      }\n    ],\n    \"PreCompact\": [\n      {\n        \"hooks\": [{\"type\": \"command\", \"command\": \"python3 /opt/hooks/main.py\"}]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|Bash\",\n        \"hooks\": [{\"type\": \"command\", \"command\": \"python3 /opt/hooks/main.py\"}]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"strategies/long-running/#3-start-claude-code","title":"3. Start Claude Code","text":"<pre><code>cd ~/my-project\nclaude\n</code></pre> <p>First session: Claude will create <code>feature_list.json</code>, <code>init.sh</code>, and initialize git.</p> <p>Subsequent sessions: Claude will read progress, verify existing features, and work on one feature at a time.</p>"},{"location":"strategies/long-running/#critical-mounting-hooks-correctly","title":"Critical: Mounting Hooks Correctly","text":"<p>Claude can modify files in its workspace. If your hooks are inside the workspace, Claude may delete or modify them to \"fix\" uncommitted changes errors.</p>"},{"location":"strategies/long-running/#the-problem_1","title":"The Problem","text":"<pre><code>workspace/\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 main.py    # \u274c Claude deleted this to fix \"uncommitted changes\"!\n\u2514\u2500\u2500 src/\n</code></pre>"},{"location":"strategies/long-running/#the-solution","title":"The Solution","text":"<p>Mount hooks outside the workspace as read-only:</p> <pre><code>/opt/hooks/          # Read-only, Claude can't modify\n\u251c\u2500\u2500 main.py\n\u2514\u2500\u2500 logs/            # Writable for logging\n\n/workspace/          # Claude's workspace\n\u251c\u2500\u2500 src/\n\u2514\u2500\u2500 feature_list.json\n</code></pre>"},{"location":"strategies/long-running/#docker-deployment-recommended","title":"Docker Deployment (Recommended)","text":"<p>The most reliable way to run LongRunningStrategy is in a Docker container with proper isolation.</p>"},{"location":"strategies/long-running/#directory-structure","title":"Directory Structure","text":"<pre><code>my-strategy-test/\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 settings.json          # Claude Code hook settings\n\u251c\u2500\u2500 claude.json            # Claude Code config (onboarding bypass)\n\u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 main.py            # Your hook script\n\u2502   \u2514\u2500\u2500 logs/              # Generated logs\n\u251c\u2500\u2500 workspace/             # Claude's project directory\n\u2514\u2500\u2500 claude-sessions/       # Persisted Claude transcripts\n</code></pre>"},{"location":"strategies/long-running/#dockerfile","title":"Dockerfile","text":"<pre><code>FROM debian:bookworm-slim\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    curl \\\n    git \\\n    ripgrep \\\n    jq \\\n    python3 \\\n    python3-pip \\\n    python3-venv \\\n    ca-certificates \\\n    gnupg \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Create python alias\nRUN ln -s /usr/bin/python3 /usr/bin/python\n\n# Install Node.js 20.x (for frontend projects)\nRUN curl -fsSL https://deb.nodesource.com/setup_20.x | bash - \\\n    &amp;&amp; apt-get install -y nodejs \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install Docker CLI (for docker compose)\nRUN install -m 0755 -d /etc/apt/keyrings \\\n    &amp;&amp; curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc \\\n    &amp;&amp; chmod a+r /etc/apt/keyrings/docker.asc \\\n    &amp;&amp; echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian bookworm stable\" &gt; /etc/apt/sources.list.d/docker.list \\\n    &amp;&amp; apt-get update \\\n    &amp;&amp; apt-get install -y docker-ce-cli docker-compose-plugin \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install uv (fast Python package manager)\nRUN curl -LsSf https://astral.sh/uv/install.sh | sh\nENV PATH=\"/root/.local/bin:$PATH\"\n\n# Install Claude Code\nRUN curl -fsSL https://claude.ai/install.sh | bash\n\n# Install fasthooks\nRUN uv pip install --system --break-system-packages fasthooks\n\nWORKDIR /workspace\nRUN mkdir -p /root/.claude\n\nCMD [\"/bin/bash\"]\n</code></pre>"},{"location":"strategies/long-running/#docker-composeyml","title":"docker-compose.yml","text":"<pre><code>services:\n  claude:\n    build: .\n    environment:\n      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}\n    volumes:\n      # Project workspace\n      - ./workspace:/workspace\n\n      # Hooks OUTSIDE workspace (read-only, except logs)\n      - ./hooks:/opt/hooks:ro\n      - ./hooks/logs:/opt/hooks/logs\n\n      # Claude Code configuration\n      - ./claude.json:/root/.claude.json\n      - ./settings.json:/root/.claude/settings.json\n\n      # Persist session transcripts for analysis\n      - ./claude-sessions:/root/.claude/projects\n\n      # Docker socket for docker/docker-compose commands\n      - /var/run/docker.sock:/var/run/docker.sock\n    stdin_open: true\n    tty: true\n</code></pre>"},{"location":"strategies/long-running/#settingsjson","title":"settings.json","text":"<pre><code>{\n  \"env\": {\n    \"DISABLE_AUTOUPDATER\": \"1\"\n  },\n  \"permissions\": {\n    \"allow\": [\"Bash\", \"Read\", \"Write\", \"Edit\"]\n  },\n  \"model\": \"sonnet\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [{\"type\": \"command\", \"command\": \"python3 /opt/hooks/main.py\"}]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [{\"type\": \"command\", \"command\": \"python3 /opt/hooks/main.py\"}]\n      }\n    ],\n    \"PreCompact\": [\n      {\n        \"hooks\": [{\"type\": \"command\", \"command\": \"python3 /opt/hooks/main.py\"}]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit|Bash\",\n        \"hooks\": [{\"type\": \"command\", \"command\": \"python3 /opt/hooks/main.py\"}]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"strategies/long-running/#hooksmainpy","title":"hooks/main.py","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Long-running agent hooks.\"\"\"\nfrom fasthooks import HookApp\nfrom fasthooks.strategies import LongRunningStrategy\n\napp = HookApp(\n    log_dir=\"/opt/hooks/logs\",\n    state_dir=\"/opt/hooks/logs\",\n)\n\nstrategy = LongRunningStrategy(\n    feature_list=\"feature_list.json\",\n    progress_file=\"claude-progress.txt\",\n    init_script=\"init.sh\",\n    min_features=30,\n    enforce_commits=True,\n    require_progress_update=True,\n    exclude_paths=[\"hooks/\", \".claude/\"],  # Ignore these in uncommitted check\n)\n\n# Log strategy events to file\nSTRATEGY_LOG = \"/opt/hooks/logs/strategy.log\"\n\n@strategy.on_observe\ndef log_events(event):\n    with open(STRATEGY_LOG, \"a\") as f:\n        f.write(f\"[{event.timestamp}] {event.event_type}: {event.hook_name}\\n\")\n        if hasattr(event, \"decision\"):\n            f.write(f\"  decision={event.decision}\\n\")\n\napp.include(strategy.get_blueprint())\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"strategies/long-running/#claudejson-bypass-onboarding","title":"claude.json (Bypass Onboarding)","text":"<pre><code>{\n  \"numStartups\": 5,\n  \"hasCompletedOnboarding\": true,\n  \"hasSeenStashHint\": true,\n  \"projects\": {\n    \"/workspace\": {\n      \"allowedTools\": [],\n      \"hasTrustDialogAccepted\": true,\n      \"projectOnboardingSeenCount\": 3\n    }\n  }\n}\n</code></pre>"},{"location":"strategies/long-running/#makefile","title":"Makefile","text":"<pre><code>.PHONY: build run debug shell logs clean\n\nbuild:\n    docker compose build\n\nrun:\n    docker compose run --rm claude claude\n\ndebug:\n    docker compose run --rm claude claude --debug\n\nshell:\n    docker compose run --rm claude bash\n\nlogs:\n    tail -f hooks/logs/strategy.log\n\nclean:\n    rm -rf workspace/* hooks/logs/*.jsonl hooks/logs/*.log\n</code></pre>"},{"location":"strategies/long-running/#running","title":"Running","text":"<pre><code># Set your API key\necho \"ANTHROPIC_API_KEY=sk-ant-...\" &gt; .env\n\n# Build the image\nmake build\n\n# Run Claude Code\nmake run\n\n# Watch strategy events in another terminal\nmake logs\n</code></pre>"},{"location":"strategies/long-running/#browser-testing-with-headless-chrome","title":"Browser Testing with Headless Chrome","text":"<p>For frontend projects, Claude can use the <code>chrome-devtools-mcp</code> server to interact with a real browser. Running headless Chrome inside the container ensures all network requests stay local (no CORS issues).</p>"},{"location":"strategies/long-running/#updated-dockerfile-with-chromium","title":"Updated Dockerfile (with Chromium)","text":"<pre><code>FROM debian:bookworm-slim\n\n# Install system dependencies + Chromium\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    curl git ripgrep jq \\\n    python3 python3-pip python3-venv \\\n    ca-certificates gnupg \\\n    chromium chromium-sandbox \\\n    fonts-liberation libnss3 libatk-bridge2.0-0 \\\n    libdrm2 libxkbcommon0 libgbm1 libasound2 \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# ... rest of Dockerfile ...\n\nCOPY entrypoint.sh /entrypoint.sh\nRUN chmod +x /entrypoint.sh\nENTRYPOINT [\"/entrypoint.sh\"]\nCMD [\"/bin/bash\"]\n</code></pre>"},{"location":"strategies/long-running/#entrypointsh","title":"entrypoint.sh","text":"<pre><code>#!/bin/bash\n# Start headless Chromium with remote debugging\nchromium \\\n  --headless \\\n  --disable-gpu \\\n  --no-sandbox \\\n  --disable-dev-shm-usage \\\n  --remote-debugging-port=9222 \\\n  --remote-debugging-address=0.0.0.0 \\\n  --user-data-dir=/tmp/chrome-profile \\\n  &amp;\n\nsleep 2\nexec \"$@\"\n</code></pre>"},{"location":"strategies/long-running/#mcp-configuration-in-claudejson","title":"MCP Configuration (in ~/.claude.json)","text":"<pre><code>{\n  \"mcpServers\": {\n    \"chrome-devtools\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"chrome-devtools-mcp@latest\", \"--browser-url=http://localhost:9222\"]\n    }\n  }\n}\n</code></pre>"},{"location":"strategies/long-running/#port-forwarding-for-manual-testing","title":"Port Forwarding for Manual Testing","text":"<p>Expose frontend/backend ports so you can test in your host browser while Claude works:</p> <pre><code># docker-compose.yml\nservices:\n  claude:\n    # ...\n    ports:\n      - \"3000:3000\"   # Frontend (Vite/React)\n      - \"8000:8000\"   # Backend (FastAPI)\n</code></pre> <p>Now you can: - Claude uses headless Chrome via MCP for automated testing - You access <code>http://localhost:3000</code> in your browser for manual testing</p>"},{"location":"strategies/long-running/#configuration-options","title":"Configuration Options","text":"<pre><code>strategy = LongRunningStrategy(\n    # File paths (relative to project root)\n    feature_list=\"feature_list.json\",    # Feature tracking file\n    progress_file=\"claude-progress.txt\", # Session notes\n    init_script=\"init.sh\",               # Environment setup script\n\n    # Requirements\n    min_features=30,                     # Minimum features to create\n\n    # Enforcement (blocking behavior)\n    enforce_commits=True,                # Block stop if uncommitted changes\n    warn_uncommitted=True,               # Warn (not block) if enforce_commits=False\n    require_progress_update=True,        # Block stop if progress not updated\n\n    # Paths to exclude from uncommitted changes check\n    exclude_paths=[\"hooks/\", \".claude/\", \".fasthooks-state/\"],\n)\n</code></pre>"},{"location":"strategies/long-running/#configuration-reference","title":"Configuration Reference","text":"Option Type Default Description <code>feature_list</code> <code>str</code> <code>\"feature_list.json\"</code> Path to feature tracking file <code>progress_file</code> <code>str</code> <code>\"claude-progress.txt\"</code> Path to session notes file <code>init_script</code> <code>str</code> <code>\"init.sh\"</code> Path to environment setup script <code>min_features</code> <code>int</code> <code>30</code> Minimum features agent must create <code>enforce_commits</code> <code>bool</code> <code>True</code> Block stop if uncommitted changes exist <code>warn_uncommitted</code> <code>bool</code> <code>True</code> Warn on uncommitted (when enforce_commits=False) <code>require_progress_update</code> <code>bool</code> <code>True</code> Block stop if progress file not updated <code>exclude_paths</code> <code>list[str]</code> <code>[\"hooks/\", \".claude/\", ...]</code> Paths to exclude from uncommitted check"},{"location":"strategies/long-running/#how-it-works","title":"How It Works","text":""},{"location":"strategies/long-running/#hook-lifecycle","title":"Hook Lifecycle","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Session Lifecycle                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502  SessionStart                                               \u2502\n\u2502      \u2502                                                      \u2502\n\u2502      \u25bc                                                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 on_session_start handler                            \u2502   \u2502\n\u2502  \u2502   - Check if feature_list.json exists               \u2502   \u2502\n\u2502  \u2502   - If NO: inject INITIALIZER context               \u2502   \u2502\n\u2502  \u2502   - If YES: inject CODING context with status       \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502      \u2502                                                      \u2502\n\u2502      \u25bc                                                      \u2502\n\u2502  [Claude works on tasks...]                                 \u2502\n\u2502      \u2502                                                      \u2502\n\u2502      \u25bc                                                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 post_tool:Write handler (on each file write)        \u2502   \u2502\n\u2502  \u2502   - Track modified files                            \u2502   \u2502\n\u2502  \u2502   - Detect progress_file updates                    \u2502   \u2502\n\u2502  \u2502   - Warn on feature_list.json structural changes    \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502      \u2502                                                      \u2502\n\u2502      \u25bc                                                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 post_tool:Bash handler (on each bash command)       \u2502   \u2502\n\u2502  \u2502   - Track git commits                               \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502      \u2502                                                      \u2502\n\u2502      \u25bc                                                      \u2502\n\u2502  [Context fills up OR user stops...]                        \u2502\n\u2502      \u2502                                                      \u2502\n\u2502      \u251c\u2500\u2500\u2500\u2500 PreCompact \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502      \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\u2502\n\u2502      \u2502  \u2502 on_pre_compact handler                       \u2502  \u2502\u2502\n\u2502      \u2502  \u2502   - Inject checkpoint reminder               \u2502  \u2502\u2502\n\u2502      \u2502  \u2502   - Show current status                      \u2502  \u2502\u2502\n\u2502      \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\u2502\n\u2502      \u2502                                                    \u2502\u2502\n\u2502      \u2514\u2500\u2500\u2500\u2500 Stop \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502         \u2502 on_stop handler                              \u2502   \u2502\n\u2502         \u2502   - Check uncommitted changes \u2192 BLOCK        \u2502   \u2502\n\u2502         \u2502   - Check progress updated \u2192 BLOCK           \u2502   \u2502\n\u2502         \u2502   - If clean \u2192 ALLOW                         \u2502   \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"strategies/long-running/#key-artifacts","title":"Key Artifacts","text":"<p>The strategy manages three critical files:</p>"},{"location":"strategies/long-running/#1-feature_listjson","title":"1. <code>feature_list.json</code>","text":"<p>Source of truth for what needs to be built:</p> <pre><code>[\n  {\n    \"category\": \"functional\",\n    \"description\": \"User can create new account\",\n    \"steps\": [\n      \"Navigate to signup page\",\n      \"Fill in email and password\",\n      \"Click submit\",\n      \"Verify account created\"\n    ],\n    \"passes\": false\n  },\n  {\n    \"category\": \"style\",\n    \"description\": \"Login button has correct styling\",\n    \"steps\": [\n      \"Navigate to login page\",\n      \"Verify button color is primary\",\n      \"Verify button has hover state\"\n    ],\n    \"passes\": true\n  }\n]\n</code></pre> <p>Rules: - Only the <code>passes</code> field can be changed - Never remove or edit features - Never modify descriptions or steps</p>"},{"location":"strategies/long-running/#2-claude-progresstxt","title":"2. <code>claude-progress.txt</code>","text":"<p>Session-by-session notes for context recovery:</p> <pre><code>## Session 3 - 2024-01-15\n\nCompleted:\n- Implemented user signup (feature #1)\n- Fixed validation bug in email field\n\nIn Progress:\n- Working on login flow (feature #2)\n\nStatus: 5/30 features passing\n\nNext session should:\n- Complete login flow\n- Start on password reset\n</code></pre>"},{"location":"strategies/long-running/#3-initsh","title":"3. <code>init.sh</code>","text":"<p>Environment setup script:</p> <pre><code>#!/bin/bash\n# Install dependencies\nnpm install\n\n# Start development server\nnpm run dev &amp;\n\necho \"Server running at http://localhost:3000\"\n</code></pre>"},{"location":"strategies/long-running/#observability","title":"Observability","text":"<p>The strategy emits events for debugging and analysis.</p>"},{"location":"strategies/long-running/#enabling-observability","title":"Enabling Observability","text":"<pre><code>from fasthooks import HookApp\nfrom fasthooks.strategies import LongRunningStrategy\n\napp = HookApp()\nstrategy = LongRunningStrategy()\n\n# Register observer callback - LOG TO FILE, NOT STDERR\n@strategy.on_observe\ndef log_events(event):\n    # WARNING: Do NOT print to stderr - it causes \"hook error\" in Claude Code\n    with open(\"/opt/hooks/logs/strategy.log\", \"a\") as f:\n        f.write(f\"[{event.event_type}] {event.hook_name}\\n\")\n        if hasattr(event, 'decision'):\n            f.write(f\"  Decision: {event.decision}\\n\")\n\napp.include(strategy.get_blueprint())\n</code></pre>"},{"location":"strategies/long-running/#event-types","title":"Event Types","text":"Event Type When Emitted Payload <code>hook_enter</code> Handler starts <code>hook_name</code> <code>hook_exit</code> Handler ends <code>hook_name</code>, <code>duration_ms</code> <code>decision</code> Handler returns allow/deny/block <code>decision</code>, <code>reason</code>, <code>message</code> <code>error</code> Handler throws exception <code>error_type</code>, <code>error_message</code> <code>custom</code> Strategy emits custom event <code>custom_event_type</code>, <code>payload</code>"},{"location":"strategies/long-running/#custom-events","title":"Custom Events","text":"<p>The strategy emits these custom events:</p> Event When Payload <code>session_type</code> Session start <code>{\"type\": \"initializer\" \\| \"coding\" \\| \"compact_resume\"}</code> <code>feature_progress</code> Session start <code>{\"passing\": 5, \"total\": 30}</code> <code>checkpoint_needed</code> Pre-compact <code>{\"reason\": \"compaction\"}</code>"},{"location":"strategies/long-running/#troubleshooting","title":"Troubleshooting","text":""},{"location":"strategies/long-running/#sessionstartstartup-hook-error","title":"\"SessionStart:startup hook error\"","text":"<p>Cause: Usually stderr output from the hook.</p> <p>Fix: Log to file instead of stderr: <pre><code># BAD - causes \"hook error\"\nprint(f\"Debug: {event}\", file=sys.stderr)\n\n# GOOD - log to file\nwith open(\"/opt/hooks/logs/debug.log\", \"a\") as f:\n    f.write(f\"Debug: {event}\\n\")\n</code></pre></p>"},{"location":"strategies/long-running/#cannot-stop-uncommitted-changes-in-hooks","title":"\"Cannot stop - uncommitted changes in: hooks/...\"","text":"<p>Cause: Hook files are in the workspace and detected as uncommitted.</p> <p>Fix: 1. Mount hooks outside workspace (see Docker Deployment) 2. Or add to <code>exclude_paths</code>: <pre><code>strategy = LongRunningStrategy(\n    exclude_paths=[\"hooks/\", \".claude/\"]\n)\n</code></pre></p>"},{"location":"strategies/long-running/#claude-deleted-hooksmainpy","title":"Claude deleted hooks/main.py","text":"<p>Cause: Hooks were in the workspace. Claude \"fixed\" uncommitted changes by deleting them.</p> <p>Fix: Mount hooks as read-only outside workspace: <pre><code>volumes:\n  - ./hooks:/opt/hooks:ro          # Read-only!\n  - ./hooks/logs:/opt/hooks/logs   # Logs writable\n</code></pre></p>"},{"location":"strategies/long-running/#cannot-stop-please-update-progress-file","title":"\"Cannot stop - please update progress file\"","text":"<p>Fix: Write to <code>claude-progress.txt</code> with your session summary.</p> <p>Or disable enforcement: <pre><code>strategy = LongRunningStrategy(require_progress_update=False)\n</code></pre></p>"},{"location":"strategies/long-running/#initializer-runs-every-session","title":"Initializer runs every session","text":"<p>The strategy checks for <code>feature_list.json</code> existence. If it keeps running initializer:</p> <ol> <li>Check that <code>feature_list.json</code> exists in the project root</li> <li>Check the file path matches your configuration</li> <li>Check the file is valid JSON</li> </ol>"},{"location":"strategies/long-running/#context-not-injected","title":"Context not injected","text":"<p>If hooks aren't being called:</p> <ol> <li>Verify settings.json is in the right location</li> <li>Check the command path is correct and executable</li> <li>Run the hook manually to test:    <pre><code>echo '{\"hook_event_name\":\"SessionStart\",\"session_id\":\"test\",\"cwd\":\"/workspace\",\"source\":\"startup\"}' | python3 /opt/hooks/main.py\n</code></pre></li> </ol>"},{"location":"strategies/long-running/#testing-the-strategy","title":"Testing the Strategy","text":""},{"location":"strategies/long-running/#local-testing-with-testclient","title":"Local Testing with TestClient","text":"<pre><code>from fasthooks import HookApp\nfrom fasthooks.strategies import LongRunningStrategy\nfrom fasthooks.testing import MockEvent, TestClient\nimport tempfile\nimport json\nfrom pathlib import Path\n\n# Create temp directory for test\ntmpdir = Path(tempfile.mkdtemp())\n\n# Create strategy\nstrategy = LongRunningStrategy(\n    min_features=5,  # Lower for testing\n    enforce_commits=False,  # Disable for testing\n    require_progress_update=False,\n)\n\n# Collect events for verification\nevents = []\nstrategy.on_observe(lambda e: events.append(e))\n\n# Create app and client\napp = HookApp(state_dir=str(tmpdir))\napp.include(strategy.get_blueprint())\nclient = TestClient(app)\n\n# Test 1: First session (no feature_list.json)\nprint(\"Test 1: Initializer mode\")\nresult = client.send(MockEvent.session_start(cwd=str(tmpdir)))\ndecision_events = [e for e in events if e.event_type == \"decision\"]\nassert any(\"INITIALIZER\" in (e.message or \"\") for e in decision_events)\nprint(\"  \u2713 Initializer context injected\")\n\n# Test 2: Create feature_list.json and test coding mode\nevents.clear()\n(tmpdir / \"feature_list.json\").write_text(json.dumps([\n    {\"description\": \"Test feature\", \"passes\": False}\n]))\n\nprint(\"Test 2: Coding mode\")\nresult = client.send(MockEvent.session_start(cwd=str(tmpdir)))\ndecision_events = [e for e in events if e.event_type == \"decision\"]\nassert any(\"0/1 passing\" in (e.message or \"\") for e in decision_events)\nprint(\"  \u2713 Coding context with status injected\")\n\nprint(\"\\nAll tests passed!\")\n</code></pre>"},{"location":"strategies/long-running/#reference","title":"Reference","text":""},{"location":"strategies/long-running/#api","title":"API","text":"<pre><code>class LongRunningStrategy(Strategy):\n    \"\"\"Harness for long-running autonomous agents.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        feature_list: str = \"feature_list.json\",\n        progress_file: str = \"claude-progress.txt\",\n        init_script: str = \"init.sh\",\n        min_features: int = 30,\n        enforce_commits: bool = True,\n        warn_uncommitted: bool = True,\n        require_progress_update: bool = True,\n        exclude_paths: list[str] | None = None,\n    ): ...\n\n    def get_blueprint(self) -&gt; Blueprint:\n        \"\"\"Return configured Blueprint with hooks.\"\"\"\n        ...\n\n    def on_observe(self, callback: Callable[[ObservabilityEvent], None]):\n        \"\"\"Register observer callback.\"\"\"\n        ...\n</code></pre>"},{"location":"strategies/long-running/#hooks-registered","title":"Hooks Registered","text":"Hook Event Purpose <code>on_session_start</code> <code>SessionStart</code> Inject initializer or coding context <code>on_stop</code> <code>Stop</code> Enforce clean state before stopping <code>on_pre_compact</code> <code>PreCompact</code> Inject checkpoint reminder <code>post_tool(\"Write\")</code> <code>PostToolUse</code> Track file creations <code>post_tool(\"Edit\")</code> <code>PostToolUse</code> Track file modifications (Claude uses Edit for updates) <code>post_tool(\"Bash\")</code> <code>PostToolUse</code> Track git commits <p>Important: Claude uses the <code>Edit</code> tool (shown as \"Update\" in UI) for file modifications, not <code>Write</code>. Make sure your PostToolUse matcher includes <code>Edit</code>!</p>"},{"location":"strategies/long-running/#further-reading","title":"Further Reading","text":"<ul> <li>Live Example: Expense Tracker built with LongRunningStrategy - Full app with hooks config and session history</li> <li>Anthropic: Effective Harnesses for Long-Running Agents - Original article this strategy implements</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Learn fasthooks step by step.</p>"},{"location":"tutorial/#overview","title":"Overview","text":"<p>This tutorial covers:</p> <ol> <li>Events - Understanding hook events and typed tool events</li> <li>Responses - Using <code>allow()</code>, <code>deny()</code>, and <code>block()</code></li> <li>Dependencies - Inject State and Transcript into handlers</li> <li>Transcript - Context engineering and memory editing</li> <li>Background Tasks - Spawn async work that feeds back later</li> <li>Blueprints - Organize handlers into reusable modules</li> <li>Middleware - Cross-cutting concerns (timing, logging)</li> <li>Testing - Writing tests with <code>MockEvent</code> and <code>TestClient</code></li> </ol>"},{"location":"tutorial/#core-concepts","title":"Core Concepts","text":""},{"location":"tutorial/#hookapp","title":"HookApp","text":"<p>The main class that registers and runs your handlers:</p> <pre><code>from fasthooks import HookApp\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef my_handler(event):\n    ...\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"tutorial/#decorators","title":"Decorators","text":"<p>Register handlers for different hook events:</p> Decorator When it runs <code>@app.pre_tool(\"Bash\")</code> Before a tool executes <code>@app.post_tool(\"Write\")</code> After a tool executes <code>@app.on_stop()</code> When Claude stops <code>@app.on_session_start()</code> When a session starts"},{"location":"tutorial/#typed-events","title":"Typed Events","text":"<p>Each tool has typed event with autocomplete:</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check(event):\n    print(event.command)      # str\n    print(event.description)  # str | None\n    print(event.timeout)      # int | None\n</code></pre>"},{"location":"tutorial/#guards","title":"Guards","text":"<p>Filter which events trigger your handler:</p> <pre><code>@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)\ndef check_sudo(event):\n    return deny(\"No sudo allowed\")\n</code></pre>"},{"location":"tutorial/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Dependencies - Access conversation history and persistent state</li> <li>Background Tasks - Async work with Claude sub-agents</li> <li>Blueprints - Split handlers into reusable modules</li> <li>Middleware - Add timing, logging, error handling to all handlers</li> </ul>"},{"location":"tutorial/background-tasks/","title":"Background Tasks","text":"<p>Background tasks let you spawn async work that runs independently and feeds back results in subsequent hook calls. This is perfect for:</p> <ul> <li>Long-running computations (code analysis, linting)</li> <li>API calls that shouldn't block the hook</li> <li>Claude sub-agents for AI-powered analysis</li> <li>Memory lookup across sessions</li> </ul>"},{"location":"tutorial/background-tasks/#quick-start","title":"Quick Start","text":"<pre><code>from fasthooks import HookApp, allow\nfrom fasthooks.tasks import task, Tasks\n\n# Define a task\n@task\ndef analyze_code(code: str) -&gt; str:\n    # This runs in a thread pool\n    import time\n    time.sleep(2)  # Simulate long operation\n    return f\"Analysis complete: {len(code)} chars\"\n\napp = HookApp()\n\n# Spawn task when code is written\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(analyze_code, event.content)\n    return allow()\n\n# Check for results on next prompt (same dependency)\n@app.on_prompt()\ndef check_results(event, tasks: Tasks):\n    if result := tasks.pop(analyze_code):\n        return allow(message=f\"Previous analysis: {result}\")\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#how-it-works","title":"How It Works","text":"<p>All task operations are non-blocking:</p> Method Behavior <code>tasks.add()</code> Submits to thread pool, returns immediately <code>tasks.pop()</code> Dict lookup, returns result or <code>None</code> instantly <code>tasks.get()</code> Dict lookup, returns <code>TaskResult</code> or <code>None</code> instantly <code>tasks.has()</code> Dict lookup, returns <code>bool</code> instantly <code>await tasks.wait()</code> Async polling, yields while waiting <p>The pattern is fire-and-forget:</p> <pre><code>Hook 1: tasks.add(my_task, args)  \u2192  queues work  \u2192  returns instantly\n        \u2193\n        ThreadPoolExecutor runs task in background\n        \u2193\nHook 2: tasks.pop(my_task)  \u2192  checks dict  \u2192  returns result (or None if still running)\n</code></pre> <p>This design ensures hooks never block on IO-bound work like API calls or database queries.</p>"},{"location":"tutorial/background-tasks/#core-concepts","title":"Core Concepts","text":""},{"location":"tutorial/background-tasks/#task-definition","title":"Task Definition","text":"<p>Use <code>@task</code> to define a background task:</p> <pre><code>from fasthooks.tasks import task\n\n@task\ndef simple_task(x: int) -&gt; int:\n    return x * 2\n\n# With options\n@task(ttl=600, priority=5)\ndef important_task(query: str) -&gt; str:\n    return search_db(query)\n\n# With result transformation\n@task(transform=lambda r: r[:500])\ndef long_output_task() -&gt; str:\n    return very_long_string()\n</code></pre> <p>Options:</p> Option Default Description <code>ttl</code> 300 Time-to-live in seconds for the result <code>priority</code> 0 Higher priority tasks may be scheduled first <code>transform</code> None Function to transform the result"},{"location":"tutorial/background-tasks/#tasks-recommended","title":"Tasks (recommended)","text":"<p>Inject <code>Tasks</code> to spawn tasks and retrieve results:</p> <pre><code>from fasthooks.tasks import Tasks\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    # Add a task (default key = function name)\n    tasks.add(my_task, arg1, arg2)\n\n    # Add with custom TTL\n    tasks.add(other_task, data, ttl=600)\n\n    return allow()\n</code></pre> <p>For multiple concurrent calls to the same function, provide an explicit <code>key</code>:</p> <pre><code>tasks.add(fetch, \"https://example.com/a\", key=\"fetch:a\")\ntasks.add(fetch, \"https://example.com/b\", key=\"fetch:b\")\n</code></pre> <p>Methods:</p> Method Description <code>add(func, *args, key=None, ttl=300, **kwargs)</code> Enqueue a task <code>cancel(key)</code> Cancel a pending/running task <code>cancel_all()</code> Cancel all tasks for this session <code>get(key)</code> Get TaskResult without removing <code>pop(key)</code> Pop completed result value <code>pop_all()</code> Pop all completed results <code>pop_errors()</code> Pop failed tasks as <code>[(key, exception), ...]</code> <code>has(key=None)</code> Check if results are ready <p><code>BackgroundTasks</code> and <code>PendingResults</code> are still available for a split enqueue/results model, but <code>Tasks</code> is the recommended DX.</p>"},{"location":"tutorial/background-tasks/#async-waiting","title":"Async Waiting","text":"<p>For handlers that need to wait for results:</p> <pre><code>@app.on_stop()\nasync def wait_for_results(event, tasks: Tasks):\n    # Wait for specific task (with timeout)\n    result = await tasks.wait(\"analysis\", timeout=10.0)\n\n    # Wait for multiple tasks\n    results = await tasks.wait_all([\"task1\", \"task2\"], timeout=30.0)\n\n    # Wait for any task to complete\n    completed = await tasks.wait_any([\"task1\", \"task2\"])\n    if completed:\n        key, result = completed\n\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#claude-sub-agents","title":"Claude Sub-Agents","text":"<p>Use the Claude Agent SDK for AI-powered background tasks:</p> <pre><code>pip install fasthooks[claude]\n</code></pre>"},{"location":"tutorial/background-tasks/#claudeagent","title":"ClaudeAgent","text":"<p>Simple wrapper for querying Claude:</p> <pre><code>from fasthooks.contrib.claude import ClaudeAgent\n\nagent = ClaudeAgent(\n    model=\"haiku\",              # haiku, sonnet, opus\n    system_prompt=\"You are helpful.\",\n    allowed_tools=[\"Read\", \"Grep\"],\n    max_turns=5,\n    max_budget_usd=0.10,\n)\n\n# Simple query\nresponse = await agent.query(\"What is 2+2?\")\n\n# Override options per-query\nresponse = await agent.query(\n    \"Analyze this code\",\n    system_prompt=\"You are a code reviewer.\",\n    max_turns=3,\n)\n</code></pre>"},{"location":"tutorial/background-tasks/#agent_task-decorator","title":"@agent_task Decorator","text":"<p>Create background tasks that use Claude:</p> <pre><code>from fasthooks.contrib.claude import ClaudeAgent, agent_task\nfrom fasthooks.tasks import Tasks\n\n@agent_task(model=\"haiku\", system_prompt=\"You review code for security issues.\")\nasync def security_review(agent: ClaudeAgent, code: str) -&gt; str:\n    return await agent.query(f\"Review for security:\\n{code}\")\n\n@agent_task(model=\"sonnet\", allowed_tools=[\"Read\", \"Grep\"])\nasync def codebase_search(agent: ClaudeAgent, query: str) -&gt; str:\n    return await agent.query(f\"Search the codebase for: {query}\")\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(security_review, event.content)\n    return allow()\n</code></pre> <p>The agent is automatically injected as the first argument.</p>"},{"location":"tutorial/background-tasks/#use-cases","title":"Use Cases","text":""},{"location":"tutorial/background-tasks/#code-review-agent","title":"Code Review Agent","text":"<pre><code>from fasthooks.contrib.claude import ClaudeAgent, agent_task\n\n@agent_task(\n    model=\"sonnet\",\n    system_prompt=\"\"\"You are a code reviewer. Check for:\n    - Security vulnerabilities\n    - Performance issues\n    - Code style problems\n    Respond with a brief summary.\"\"\"\n)\nasync def review_code(agent: ClaudeAgent, code: str, file_path: str) -&gt; str:\n    return await agent.query(f\"Review {file_path}:\\n```\\n{code}\\n```\")\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    if event.file_path.endswith(\".py\"):\n        tasks.add(review_code, event.content, event.file_path)\n    return allow()\n\n@app.on_prompt()\ndef show_review(event, tasks: Tasks):\n    if review := tasks.pop(review_code):\n        return allow(message=f\"Code review:\\n{review}\")\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#memorycontext-lookup","title":"Memory/Context Lookup","text":"<pre><code>@task\ndef search_memory(query: str, session_id: str) -&gt; str:\n    # Search vector DB, knowledge base, etc.\n    results = vector_db.search(query, filter={\"session\": session_id})\n    return \"\\n\".join(r.text for r in results[:3])\n\n@app.on_prompt()\ndef enrich_prompt(event, tasks: Tasks):\n    # Check for previous search results\n    if context := tasks.pop(search_memory):\n        return allow(message=f\"Relevant context:\\n{context}\")\n\n    # Start new search based on prompt\n    tasks.add(search_memory, event.prompt, event.session_id)\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#rate-limited-api-calls","title":"Rate-Limited API Calls","text":"<pre><code>import httpx\n\n@task(ttl=600)  # Cache for 10 minutes\ndef fetch_documentation(url: str) -&gt; str:\n    response = httpx.get(url)\n    return response.text[:5000]\n\n@app.pre_tool(\"WebFetch\")\ndef prefetch_docs(event, tasks: Tasks):\n    # Start fetching in background\n    tasks.add(fetch_documentation, event.url, key=f\"doc:{event.url}\")\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#testing","title":"Testing","text":"<p>Use <code>ImmediateBackend</code> for synchronous testing:</p> <pre><code>from fasthooks.tasks import task, Tasks\nfrom fasthooks.tasks.testing import ImmediateBackend\n\n@task\ndef double(x: int) -&gt; int:\n    return x * 2\n\ndef test_background_task():\n    backend = ImmediateBackend()\n\n    tasks = Tasks(backend, session_id=\"test\")\n    tasks.add(double, 5)\n    assert tasks.pop(double) == 10\n</code></pre>"},{"location":"tutorial/background-tasks/#error-handling","title":"Error Handling","text":"<p>Tasks that fail store their exceptions:</p> <pre><code>@task\ndef risky_task() -&gt; str:\n    raise ValueError(\"Something went wrong\")\n\n@app.on_prompt()\ndef check_errors(event, tasks: Tasks):\n    # Pop all failed tasks\n    for key, error in tasks.pop_errors():\n        print(f\"Task {key} failed: {error}\")\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#task-status","title":"Task Status","text":"<p>Check detailed task status via <code>TaskResult</code>:</p> <pre><code>from fasthooks.tasks import TaskStatus\n\n@app.on_prompt()\ndef check_status(event, tasks: Tasks):\n    result = tasks.get(\"my-task\")\n    if result:\n        if result.status == TaskStatus.COMPLETED:\n            print(f\"Done: {result.value}\")\n        elif result.status == TaskStatus.RUNNING:\n            print(\"Still running...\")\n        elif result.status == TaskStatus.FAILED:\n            print(f\"Error: {result.error}\")\n    return allow()\n</code></pre> <p>Status values:</p> Status Description <code>PENDING</code> Queued, not started <code>RUNNING</code> Currently executing <code>COMPLETED</code> Finished successfully <code>FAILED</code> Exception raised <code>CANCELLED</code> Cancelled by user"},{"location":"tutorial/blueprints/","title":"Blueprints","text":"<p>Blueprints let you organize handlers into reusable, composable modules.</p>"},{"location":"tutorial/blueprints/#why-blueprints","title":"Why Blueprints?","text":"<p>As your hooks grow, a single file becomes hard to manage:</p> <pre><code># hooks.py - getting messy!\n@app.pre_tool(\"Bash\")\ndef security_check(event): ...\n\n@app.pre_tool(\"Write\")\ndef security_write(event): ...\n\n@app.pre_tool(\"Bash\")\ndef logging_bash(event): ...\n\n@app.post_tool(\"Write\")\ndef logging_write(event): ...\n\n@app.on_stop()\ndef cleanup(event): ...\n</code></pre> <p>Blueprints let you split by concern:</p> <pre><code>hooks/\n\u251c\u2500\u2500 __init__.py      # Main app\n\u251c\u2500\u2500 security.py      # Security rules\n\u251c\u2500\u2500 logging.py       # Audit logging\n\u2514\u2500\u2500 cleanup.py       # Session cleanup\n</code></pre>"},{"location":"tutorial/blueprints/#basic-usage","title":"Basic Usage","text":"<pre><code># security.py\nfrom fasthooks import Blueprint, deny\n\nsecurity = Blueprint(\"security\")\n\n@security.pre_tool(\"Bash\")\ndef no_dangerous_commands(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n\n@security.pre_tool(\"Write\")\ndef protect_sensitive_files(event):\n    if \".env\" in event.file_path:\n        return deny(\"Cannot modify .env files\")\n</code></pre> <pre><code># hooks.py\nfrom fasthooks import HookApp\nfrom security import security\n\napp = HookApp()\napp.include(security)\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"tutorial/blueprints/#blueprint-api","title":"Blueprint API","text":"<p>Blueprints support the same decorators as HookApp:</p> <pre><code>from fasthooks import Blueprint\n\nbp = Blueprint(\"my-blueprint\")\n\n# Tool events\n@bp.pre_tool(\"Bash\")\ndef check(event): ...\n\n@bp.post_tool(\"Write\")\ndef after(event): ...\n\n@bp.on_permission(\"Bash\")\ndef perm(event): ...\n\n# Lifecycle events\n@bp.on_stop()\ndef stop(event): ...\n\n@bp.on_session_start()\ndef start(event): ...\n</code></pre>"},{"location":"tutorial/blueprints/#real-world-examples","title":"Real-World Examples","text":""},{"location":"tutorial/blueprints/#security-blueprint","title":"Security Blueprint","text":"<pre><code># blueprints/security.py\nfrom fasthooks import Blueprint, deny\n\nsecurity = Blueprint(\"security\")\n\nDANGEROUS_PATTERNS = [\n    \"rm -rf\",\n    \"mkfs\",\n    \"&gt; /dev/sd\",\n    \"dd if=\",\n]\n\nPROTECTED_PATHS = [\n    \".env\",\n    \".ssh\",\n    \"credentials\",\n    \"secrets\",\n]\n\n@security.pre_tool(\"Bash\")\ndef block_dangerous_commands(event):\n    for pattern in DANGEROUS_PATTERNS:\n        if pattern in event.command:\n            return deny(f\"Blocked: contains '{pattern}'\")\n\n@security.pre_tool(\"Write\")\ndef protect_files(event):\n    for path in PROTECTED_PATHS:\n        if path in event.file_path:\n            return deny(f\"Cannot write to {path}\")\n\n@security.pre_tool(\"Edit\")\ndef protect_edits(event):\n    for path in PROTECTED_PATHS:\n        if path in event.file_path:\n            return deny(f\"Cannot edit {path}\")\n</code></pre>"},{"location":"tutorial/blueprints/#logging-blueprint","title":"Logging Blueprint","text":"<pre><code># blueprints/logging.py\nfrom fasthooks import Blueprint\nfrom fasthooks.depends import State\nfrom datetime import datetime\n\nlogging = Blueprint(\"logging\")\n\n@logging.post_tool(\"Bash\")\ndef log_bash(event, state: State):\n    logs = state.get(\"bash_log\", [])\n    logs.append({\n        \"command\": event.command,\n        \"time\": datetime.now().isoformat(),\n    })\n    state[\"bash_log\"] = logs[-100:]  # Keep last 100\n    state.save()\n\n@logging.post_tool(\"Write\")\ndef log_write(event, state: State):\n    logs = state.get(\"write_log\", [])\n    logs.append({\n        \"file\": event.file_path,\n        \"time\": datetime.now().isoformat(),\n    })\n    state[\"write_log\"] = logs[-100:]\n    state.save()\n</code></pre>"},{"location":"tutorial/blueprints/#rate-limiting-blueprint","title":"Rate Limiting Blueprint","text":"<pre><code># blueprints/rate_limit.py\nfrom fasthooks import Blueprint, deny\nfrom fasthooks.depends import State\n\nrate_limit = Blueprint(\"rate-limit\")\n\nLIMITS = {\n    \"Bash\": 100,\n    \"Write\": 50,\n    \"Edit\": 50,\n}\n\n@rate_limit.pre_tool(\"*\")\ndef check_rate(event, state: State):\n    tool = event.tool_name\n    if tool not in LIMITS:\n        return\n\n    key = f\"rate_{tool}\"\n    count = state.get(key, 0) + 1\n    state[key] = count\n    state.save()\n\n    limit = LIMITS[tool]\n    if count &gt; limit:\n        return deny(f\"Rate limit exceeded: {count}/{limit} {tool} calls\")\n</code></pre>"},{"location":"tutorial/blueprints/#composing-multiple-blueprints","title":"Composing Multiple Blueprints","text":"<pre><code># hooks.py\nfrom fasthooks import HookApp\nfrom blueprints.security import security\nfrom blueprints.logging import logging\nfrom blueprints.rate_limit import rate_limit\n\napp = HookApp(state_dir=\"/tmp/fasthooks-state\")\n\n# Include all blueprints\napp.include(security)\napp.include(logging)\napp.include(rate_limit)\n\n# Add app-specific handlers\n@app.on_stop()\ndef final_check(event):\n    ...\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"tutorial/blueprints/#when-to-use-blueprints","title":"When to Use Blueprints","text":"Scenario Blueprint? Single file with &lt;10 handlers No Handlers grouped by concern (security, logging) Yes Reusable rules across projects Yes Team members working on different features Yes Conditionally enabling feature sets Yes"},{"location":"tutorial/blueprints/#blueprint-vs-middleware","title":"Blueprint vs Middleware","text":"<ul> <li>Blueprints: Organize handlers by feature/concern</li> <li>Middleware: Cross-cutting logic that wraps ALL handlers</li> </ul> <p>Use blueprints when you want modular organization. Use middleware when you want universal behavior (timing, logging every call).</p>"},{"location":"tutorial/dependencies/","title":"Dependency Injection","text":"<p>fasthooks automatically injects dependencies into your handlers based on type hints. This gives you access to conversation history, persistent state, and more.</p>"},{"location":"tutorial/dependencies/#why-dependency-injection","title":"Why Dependency Injection?","text":"<p>Without DI, your handler only sees the current event:</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check(event):\n    # Only know about THIS bash command\n    # No context about what happened before\n    pass\n</code></pre> <p>With DI, you get full conversation context:</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check(event, transcript: Transcript, state: State):\n    # transcript: Full conversation history, token counts, all tool calls\n    # state: Persistent dict that survives between hook invocations\n    pass\n</code></pre>"},{"location":"tutorial/dependencies/#available-dependencies","title":"Available Dependencies","text":"Dependency Description <code>Transcript</code> Conversation history and statistics <code>State</code> Persistent session-scoped storage <code>Tasks</code> Background task enqueue + results"},{"location":"tutorial/dependencies/#transcript","title":"Transcript","text":"<p>Access the full conversation history. Lazy-loaded and cached - no performance penalty if unused.</p> <pre><code>from fasthooks.depends import Transcript\n\n@app.pre_tool(\"Bash\")\ndef check(event, transcript: Transcript):\n    stats = transcript.stats\n\n    # Token usage\n    print(f\"Tokens: {stats.input_tokens} in / {stats.output_tokens} out\")\n\n    # Tool usage\n    print(f\"Tool calls: {stats.tool_calls}\")  # {\"Bash\": 5, \"Write\": 2}\n    print(f\"Errors: {stats.error_count}\")\n\n    # Entries\n    print(f\"Messages: {len(transcript.entries)}\")\n    print(f\"Turns: {stats.turn_count}\")\n</code></pre> <p>The Transcript provides rich querying, CRUD operations, and context engineering capabilities.</p> <p>See Transcript &amp; Context Engineering for full documentation.</p> <p>Quick overview:</p> Feature Example Query entries <code>transcript.query().assistants().with_tools().all()</code> Statistics <code>transcript.stats.input_tokens</code> Create entries <code>UserMessage.create(\"reminder\", context=entry)</code> Inject tool results <code>inject_tool_result(transcript, \"Bash\", {...}, \"output\")</code> Export <code>transcript.to_markdown()</code>, <code>transcript.to_file(\"out.md\")</code>"},{"location":"tutorial/dependencies/#state","title":"State","text":"<p>Persistent dict that survives between hook invocations. Backed by a JSON file.</p> <pre><code>from fasthooks.depends import State\n\n# Enable state by configuring state_dir\napp = HookApp(state_dir=\"/tmp/fasthooks-state\")\n\n@app.pre_tool(\"Bash\")\ndef rate_limit(event, state: State):\n    # Count commands per session\n    count = state.get(\"bash_count\", 0) + 1\n    state[\"bash_count\"] = count\n    state.save()  # Persist to disk\n\n    if count &gt; 100:\n        return deny(\"Too many bash commands in this session\")\n</code></pre>"},{"location":"tutorial/dependencies/#state-methods","title":"State Methods","text":"Method Description <code>state.save()</code> Persist to disk <code>state.get(key, default)</code> Get with default <code>state[key] = value</code> Set value <code>key in state</code> Check existence <p>State is scoped to the session - each session gets its own JSON file.</p>"},{"location":"tutorial/dependencies/#tasks","title":"Tasks","text":"<p>Enqueue background tasks and retrieve results. See Background Tasks for full details.</p> <pre><code>from fasthooks.tasks import Tasks\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    # Enqueue (key defaults to function name)\n    tasks.add(analyze_code, event.content)\n\n@app.on_prompt()\ndef check(event, tasks: Tasks):\n    # Pop by function reference\n    if result := tasks.pop(analyze_code):\n        return allow(message=f\"Analysis: {result}\")\n</code></pre>"},{"location":"tutorial/dependencies/#use-cases","title":"Use Cases","text":""},{"location":"tutorial/dependencies/#rate-limiting","title":"Rate Limiting","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef rate_limit(event, state: State):\n    count = state.get(\"commands\", 0) + 1\n    state[\"commands\"] = count\n    state.save()\n\n    if count &gt; 50:\n        return deny(f\"Rate limit: {count}/50 commands used\")\n</code></pre>"},{"location":"tutorial/dependencies/#token-budget","title":"Token Budget","text":"<pre><code>@app.on_stop()\ndef check_budget(event, transcript: Transcript):\n    stats = transcript.stats\n    total = stats.input_tokens + stats.output_tokens\n\n    if total &gt; 100_000:\n        return allow(message=f\"Warning: {total:,} tokens used\")\n</code></pre>"},{"location":"tutorial/dependencies/#command-history-analysis","title":"Command History Analysis","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef no_repeated_failures(event, transcript: Transcript):\n    # Query recent Bash tool uses\n    recent = transcript.query().tool_uses(\"Bash\").last(5).all()\n    recent_commands = [e.tool_input.get(\"command\") for e in recent]\n    if event.command in recent_commands:\n        return deny(\"This command was already tried recently\")\n</code></pre>"},{"location":"tutorial/dependencies/#audit-logging","title":"Audit Logging","text":"<pre><code>@app.post_tool(\"Write\")\ndef audit_writes(event, state: State):\n    writes = state.get(\"writes\", [])\n    writes.append({\n        \"file\": event.file_path,\n        \"time\": datetime.now().isoformat(),\n    })\n    state[\"writes\"] = writes\n    state.save()\n</code></pre>"},{"location":"tutorial/dependencies/#context-aware-decisions","title":"Context-Aware Decisions","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef context_check(event, transcript: Transcript):\n    stats = transcript.stats\n\n    # More permissive if user has been working a while\n    if stats.duration_seconds &gt; 3600:  # 1 hour\n        return allow()\n\n    # Stricter for new sessions\n    if \"rm\" in event.command:\n        return deny(\"Destructive commands require established session\")\n</code></pre>"},{"location":"tutorial/dependencies/#how-it-works","title":"How It Works","text":"<ol> <li>fasthooks inspects your handler's type hints</li> <li>For each <code>Transcript</code> or <code>State</code> parameter, it creates the dependency</li> <li>Dependencies are passed when calling your handler</li> </ol> <pre><code># fasthooks sees: def check(event, transcript: Transcript, state: State)\n# And calls: check(event, transcript=Transcript(...), state=State(...))\n</code></pre> <p>Dependencies are created fresh for each hook invocation, but: - <code>Transcript</code> lazily loads and caches parsed data - <code>State</code> loads from disk and persists on <code>.save()</code></p>"},{"location":"tutorial/events/","title":"Events","text":"<p>Claude Code sends different events to your hooks. fasthooks provides typed classes for each.</p>"},{"location":"tutorial/events/#hook-event-types","title":"Hook Event Types","text":""},{"location":"tutorial/events/#pretooluse","title":"PreToolUse","text":"<p>Runs before a tool executes. Can allow, deny, or modify the tool call.</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Blocked dangerous command\")\n</code></pre>"},{"location":"tutorial/events/#posttooluse","title":"PostToolUse","text":"<p>Runs after a tool executes successfully. Can provide feedback to Claude.</p> <pre><code>@app.post_tool(\"Write\")\ndef after_write(event):\n    # event.tool_response contains the result\n    if event.tool_response.get(\"success\"):\n        print(f\"Wrote to {event.file_path}\")\n</code></pre>"},{"location":"tutorial/events/#permissionrequest","title":"PermissionRequest","text":"<p>Runs when Claude asks for permission. Can auto-allow or auto-deny.</p> <pre><code>@app.on_permission(\"Bash\")\ndef auto_allow_safe(event):\n    if event.command.startswith(\"ls\"):\n        return allow()  # Auto-approve ls commands\n</code></pre>"},{"location":"tutorial/events/#stop-subagentstop","title":"Stop / SubagentStop","text":"<p>Runs when Claude (or a subagent) is about to stop.</p> <pre><code>@app.on_stop()\ndef on_stop(event):\n    if event.stop_hook_active:\n        return allow()  # Prevent infinite loops\n    # Check if work is complete...\n    return block(\"Please run the tests first\")\n</code></pre>"},{"location":"tutorial/events/#sessionstart-sessionend","title":"SessionStart / SessionEnd","text":"<p>Runs at session lifecycle events.</p> <pre><code>@app.on_session_start()\ndef on_start(event):\n    print(f\"Session started: {event.source}\")  # startup, resume, clear\n</code></pre>"},{"location":"tutorial/events/#tool-events","title":"Tool Events","text":"<p>Each tool has a typed event class with specific properties.</p>"},{"location":"tutorial/events/#bash","title":"Bash","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef check(event):\n    event.command      # str - the command to run\n    event.description  # str | None - optional description\n    event.timeout      # int | None - timeout in ms\n</code></pre>"},{"location":"tutorial/events/#write","title":"Write","text":"<pre><code>@app.pre_tool(\"Write\")\ndef check(event):\n    event.file_path  # str - path to write\n    event.content    # str - file content\n</code></pre>"},{"location":"tutorial/events/#edit","title":"Edit","text":"<pre><code>@app.pre_tool(\"Edit\")\ndef check(event):\n    event.file_path   # str - path to edit\n    event.old_string  # str - text to find\n    event.new_string  # str - replacement text\n</code></pre>"},{"location":"tutorial/events/#read","title":"Read","text":"<pre><code>@app.pre_tool(\"Read\")\ndef check(event):\n    event.file_path  # str - path to read\n    event.offset     # int | None - line offset\n    event.limit      # int | None - line limit\n</code></pre>"},{"location":"tutorial/events/#grep-glob","title":"Grep / Glob","text":"<pre><code>@app.pre_tool(\"Grep\")\ndef check(event):\n    event.pattern  # str - search pattern\n    event.path     # str | None - search path\n</code></pre>"},{"location":"tutorial/events/#catch-all-handlers","title":"Catch-All Handlers","text":"<p>Use <code>\"*\"</code> or omit the tool name to match all tools:</p> <pre><code>@app.pre_tool(\"*\")\ndef log_all(event):\n    print(f\"Tool: {event.tool_name}\")\n\n# Or without argument\n@app.pre_tool()\ndef log_all(event):\n    print(f\"Tool: {event.tool_name}\")\n</code></pre>"},{"location":"tutorial/events/#common-fields","title":"Common Fields","text":"<p>All events have these fields:</p> <pre><code>event.session_id       # str - session identifier\nevent.cwd              # str - current working directory\nevent.permission_mode  # str - default, plan, acceptEdits, bypassPermissions\nevent.transcript_path  # str | None - path to conversation JSON\n</code></pre> <p>Tool events also have:</p> <pre><code>event.tool_name     # str - Bash, Write, Edit, etc.\nevent.tool_input    # dict - raw input parameters\nevent.tool_use_id   # str - unique tool call ID\n</code></pre>"},{"location":"tutorial/middleware/","title":"Middleware","text":"<p>Middleware wraps ALL handler calls, letting you add cross-cutting behavior like timing, logging, or error handling.</p>"},{"location":"tutorial/middleware/#why-middleware","title":"Why Middleware?","text":"<p>Some behaviors should apply to every handler:</p> <ul> <li>Timing how long handlers take</li> <li>Logging all events</li> <li>Error handling and recovery</li> <li>Authentication/authorization</li> </ul> <p>Without middleware, you'd duplicate this in every handler:</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    start = time.time()\n    try:\n        result = do_check(event)\n        logger.info(f\"Bash check took {time.time() - start:.3f}s\")\n        return result\n    except Exception as e:\n        logger.error(f\"Error: {e}\")\n        raise\n\n# Repeat for every handler... \ud83d\ude29\n</code></pre> <p>With middleware:</p> <pre><code>@app.middleware\ndef timing(event, call_next):\n    start = time.time()\n    result = call_next(event)\n    print(f\"Handlers took {time.time() - start:.3f}s\")\n    return result\n\n# Automatically wraps ALL handlers \u2728\n</code></pre>"},{"location":"tutorial/middleware/#basic-usage","title":"Basic Usage","text":"<pre><code>from fasthooks import HookApp\n\napp = HookApp()\n\n@app.middleware\ndef my_middleware(event, call_next):\n    # Before handlers\n    print(f\"Processing {event.hook_event_name}\")\n\n    # Call the handler chain\n    result = call_next(event)\n\n    # After handlers\n    print(f\"Result: {result}\")\n\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#how-it-works","title":"How It Works","text":"<pre><code>Event \u2192 Middleware 1 \u2192 Middleware 2 \u2192 ... \u2192 Handlers \u2192 Response\n              \u2193              \u2193                  \u2193\n          call_next      call_next          execute\n</code></pre> <ol> <li>Event enters the middleware chain</li> <li>Each middleware calls <code>call_next(event)</code> to continue</li> <li>Handlers execute and return a response</li> <li>Response bubbles back through middleware</li> <li>Final response returned</li> </ol>"},{"location":"tutorial/middleware/#common-patterns","title":"Common Patterns","text":""},{"location":"tutorial/middleware/#timing","title":"Timing","text":"<pre><code>import time\n\n@app.middleware\ndef timing(event, call_next):\n    start = time.time()\n    result = call_next(event)\n    elapsed = time.time() - start\n    print(f\"[{event.hook_event_name}] {elapsed:.3f}s\")\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#logging","title":"Logging","text":"<pre><code>import logging\n\nlogger = logging.getLogger(\"hooks\")\n\n@app.middleware\ndef log_events(event, call_next):\n    logger.info(f\"Event: {event.hook_event_name}\")\n    if hasattr(event, \"tool_name\"):\n        logger.info(f\"Tool: {event.tool_name}\")\n\n    result = call_next(event)\n\n    if result:\n        logger.info(f\"Decision: {result.decision}\")\n\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#error-handling","title":"Error Handling","text":"<pre><code>@app.middleware\ndef error_handler(event, call_next):\n    try:\n        return call_next(event)\n    except Exception as e:\n        print(f\"Handler error: {e}\")\n        # Return None to allow (fail-open)\n        # Or return deny(\"Internal error\") to fail-closed\n        return None\n</code></pre>"},{"location":"tutorial/middleware/#conditional-processing","title":"Conditional Processing","text":"<pre><code>@app.middleware\ndef skip_in_plan_mode(event, call_next):\n    # Skip all checks in plan mode\n    if event.permission_mode == \"plan\":\n        return None\n\n    return call_next(event)\n</code></pre>"},{"location":"tutorial/middleware/#response-modification","title":"Response Modification","text":"<pre><code>@app.middleware\ndef add_warnings(event, call_next):\n    result = call_next(event)\n\n    # Add warning to all denials\n    if result and result.decision == \"deny\":\n        result.message = f\"\u26a0\ufe0f Blocked: {result.reason}\"\n\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#async-middleware","title":"Async Middleware","text":"<p>Middleware can be async:</p> <pre><code>@app.middleware\nasync def async_middleware(event, call_next):\n    # Async operations allowed\n    await some_async_check()\n\n    result = await call_next(event)\n\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#multiple-middleware","title":"Multiple Middleware","text":"<p>Middleware executes in registration order:</p> <pre><code>@app.middleware\ndef first(event, call_next):\n    print(\"1. First - before\")\n    result = call_next(event)\n    print(\"4. First - after\")\n    return result\n\n@app.middleware\ndef second(event, call_next):\n    print(\"2. Second - before\")\n    result = call_next(event)\n    print(\"3. Second - after\")\n    return result\n\n# Output:\n# 1. First - before\n# 2. Second - before\n# (handlers run)\n# 3. Second - after\n# 4. First - after\n</code></pre>"},{"location":"tutorial/middleware/#short-circuiting","title":"Short-Circuiting","text":"<p>Return early to skip handlers:</p> <pre><code>from fasthooks import deny\n\n@app.middleware\ndef auth_check(event, call_next):\n    # Block everything if not authorized\n    if not is_authorized():\n        return deny(\"Not authorized\")\n\n    # Otherwise continue to handlers\n    return call_next(event)\n</code></pre>"},{"location":"tutorial/middleware/#real-world-example","title":"Real-World Example","text":"<pre><code>import time\nimport logging\nfrom fasthooks import HookApp, deny\n\napp = HookApp()\nlogger = logging.getLogger(\"hooks\")\n\n@app.middleware\ndef comprehensive_middleware(event, call_next):\n    # 1. Log incoming event\n    start = time.time()\n    event_info = f\"{event.hook_event_name}\"\n    if hasattr(event, \"tool_name\"):\n        event_info += f\":{event.tool_name}\"\n    logger.info(f\"\u2192 {event_info}\")\n\n    # 2. Skip processing in certain modes\n    if event.permission_mode == \"bypassPermissions\":\n        logger.info(\"  Skipping (bypass mode)\")\n        return None\n\n    # 3. Execute handlers with error handling\n    try:\n        result = call_next(event)\n    except Exception as e:\n        logger.error(f\"  Error: {e}\")\n        return deny(f\"Internal error: {e}\")\n\n    # 4. Log result\n    elapsed = time.time() - start\n    decision = result.decision if result else \"allow\"\n    logger.info(f\"\u2190 {event_info} [{decision}] ({elapsed:.3f}s)\")\n\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#middleware-vs-blueprints-vs-guards","title":"Middleware vs Blueprints vs Guards","text":"Feature Use Case Middleware Universal behavior (timing, logging, auth) Blueprints Organizing handlers by feature Guards Filtering which events trigger a handler <pre><code># Middleware: runs for EVERY event\n@app.middleware\ndef timing(event, call_next): ...\n\n# Blueprint: groups related handlers\nsecurity = Blueprint(\"security\")\n\n# Guard: filters specific handler\n@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)\ndef check_sudo(event): ...\n</code></pre>"},{"location":"tutorial/responses/","title":"Responses","text":"<p>Control Claude Code's behavior by returning responses from your handlers.</p>"},{"location":"tutorial/responses/#response-types","title":"Response Types","text":""},{"location":"tutorial/responses/#allow","title":"allow()","text":"<p>Explicitly allow the action. For PreToolUse, bypasses permission prompts.</p> <pre><code>from fasthooks import allow\n\n@app.pre_tool(\"Read\")\ndef allow_docs(event):\n    if event.file_path.endswith(\".md\"):\n        return allow()  # Auto-approve reading markdown\n</code></pre>"},{"location":"tutorial/responses/#denyreason","title":"deny(reason)","text":"<p>Block the action with a reason shown to Claude.</p> <pre><code>from fasthooks import deny\n\n@app.pre_tool(\"Bash\")\ndef no_dangerous(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n</code></pre>"},{"location":"tutorial/responses/#blockreason","title":"block(reason)","text":"<p>For Stop/SubagentStop hooks - prevent Claude from stopping.</p> <pre><code>from fasthooks import block\n\n@app.on_stop()\ndef ensure_tests(event):\n    # Check if tests were run...\n    if not tests_passed:\n        return block(\"Please run the tests before stopping\")\n</code></pre>"},{"location":"tutorial/responses/#none-implicit-allow","title":"None (implicit allow)","text":"<p>Return <code>None</code> or nothing to allow the action without bypassing permissions.</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check(event):\n    if is_dangerous(event.command):\n        return deny(\"Blocked\")\n    # Implicit allow - normal permission flow continues\n</code></pre>"},{"location":"tutorial/responses/#response-options","title":"Response Options","text":""},{"location":"tutorial/responses/#message","title":"message","text":"<p>Add a system message shown to the user:</p> <pre><code>return allow(message=\"This file is sensitive\")\n</code></pre>"},{"location":"tutorial/responses/#interrupt","title":"interrupt","text":"<p>Stop Claude entirely (not just block this action):</p> <pre><code>return deny(\"Session limit reached\", interrupt=True)\n</code></pre>"},{"location":"tutorial/responses/#response-by-hook-type","title":"Response by Hook Type","text":"Hook Type allow() deny() block() None PreToolUse Bypass permission Block tool - Normal flow PostToolUse - Feedback to Claude - No action PermissionRequest Auto-approve Auto-deny - Show prompt Stop Allow stop - Prevent stop Allow stop"},{"location":"tutorial/responses/#examples","title":"Examples","text":""},{"location":"tutorial/responses/#auto-approve-safe-commands","title":"Auto-approve safe commands","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef auto_approve(event):\n    safe_commands = [\"ls\", \"pwd\", \"echo\", \"cat\"]\n    cmd = event.command.split()[0]\n    if cmd in safe_commands:\n        return allow()\n    # Let other commands go through normal permission flow\n</code></pre>"},{"location":"tutorial/responses/#block-sensitive-files","title":"Block sensitive files","text":"<pre><code>SENSITIVE = [\".env\", \"credentials\", \"secrets\", \".ssh\"]\n\n@app.pre_tool(\"Write\")\ndef protect_sensitive(event):\n    for pattern in SENSITIVE:\n        if pattern in event.file_path:\n            return deny(f\"Cannot write to {pattern} files\")\n</code></pre>"},{"location":"tutorial/responses/#ensure-work-completion","title":"Ensure work completion","text":"<pre><code>@app.on_stop()\ndef check_completion(event):\n    if event.stop_hook_active:\n        return allow()  # Prevent infinite loop\n\n    # Could check transcript, run tests, etc.\n    return block(\"Please verify all tests pass before stopping\")\n</code></pre>"},{"location":"tutorial/testing/","title":"Testing","text":"<p>fasthooks provides utilities for testing your hooks without Claude Code.</p>"},{"location":"tutorial/testing/#mockevent","title":"MockEvent","text":"<p>Create typed test events:</p> <pre><code>from fasthooks.testing import MockEvent\n\n# Create a Bash event\nevent = MockEvent.bash(command=\"ls -la\")\nprint(event.command)  # \"ls -la\"\n\n# Create a Write event\nevent = MockEvent.write(\n    file_path=\"/tmp/test.txt\",\n    content=\"Hello world\"\n)\nprint(event.file_path)  # \"/tmp/test.txt\"\n</code></pre>"},{"location":"tutorial/testing/#available-mock-events","title":"Available Mock Events","text":""},{"location":"tutorial/testing/#tool-events-pretooluse","title":"Tool Events (PreToolUse)","text":"<pre><code>MockEvent.bash(command=\"echo hello\")\nMockEvent.write(file_path=\"/tmp/f.txt\", content=\"...\")\nMockEvent.read(file_path=\"/tmp/f.txt\")\nMockEvent.edit(file_path=\"/tmp/f.txt\", old_string=\"a\", new_string=\"b\")\n</code></pre>"},{"location":"tutorial/testing/#permission-events","title":"Permission Events","text":"<pre><code>MockEvent.permission_bash(command=\"rm -rf /\")\nMockEvent.permission_write(file_path=\"/etc/passwd\", content=\"...\")\nMockEvent.permission_edit(file_path=\"/etc/hosts\", old_string=\"a\", new_string=\"b\")\n</code></pre>"},{"location":"tutorial/testing/#lifecycle-events","title":"Lifecycle Events","text":"<pre><code>MockEvent.stop()\nMockEvent.stop(stop_hook_active=True)\nMockEvent.session_start(source=\"startup\")\nMockEvent.pre_compact(trigger=\"manual\")\n</code></pre>"},{"location":"tutorial/testing/#testclient","title":"TestClient","text":"<p>Test your handlers end-to-end:</p> <pre><code>from fasthooks.testing import TestClient, MockEvent\nfrom my_hooks import app\n\nclient = TestClient(app)\n\ndef test_allows_safe_commands():\n    response = client.send(MockEvent.bash(command=\"ls -la\"))\n    assert response is None  # Allowed\n\ndef test_blocks_dangerous_commands():\n    response = client.send(MockEvent.bash(command=\"rm -rf /\"))\n    assert response.decision == \"deny\"\n    assert \"dangerous\" in response.reason.lower()\n</code></pre>"},{"location":"tutorial/testing/#example-test-file","title":"Example Test File","text":"<pre><code># test_hooks.py\nimport pytest\nfrom fasthooks.testing import TestClient, MockEvent\nfrom hooks import app\n\n@pytest.fixture\ndef client():\n    return TestClient(app)\n\nclass TestBashHooks:\n    def test_allows_ls(self, client):\n        response = client.send(MockEvent.bash(command=\"ls\"))\n        assert response is None\n\n    def test_blocks_rm_rf(self, client):\n        response = client.send(MockEvent.bash(command=\"rm -rf /\"))\n        assert response is not None\n        assert response.decision == \"deny\"\n\nclass TestWriteHooks:\n    def test_blocks_env_files(self, client):\n        response = client.send(MockEvent.write(\n            file_path=\".env\",\n            content=\"SECRET=123\"\n        ))\n        assert response.decision == \"deny\"\n\n    def test_allows_normal_files(self, client):\n        response = client.send(MockEvent.write(\n            file_path=\"readme.md\",\n            content=\"# Hello\"\n        ))\n        assert response is None\n</code></pre> <p>Run tests:</p> <pre><code>pytest test_hooks.py -v\n</code></pre>"},{"location":"tutorial/testing/#cli-testing","title":"CLI Testing","text":"<p>You can also test via the CLI:</p> <pre><code># Generate test event\nfasthooks example bash_dangerous &gt; event.json\n\n# Run hook and check output\nfasthooks run hooks.py --input event.json\n</code></pre> <p>This outputs the JSON response directly, useful for quick manual testing.</p>"},{"location":"tutorial/transcript/","title":"Transcript &amp; Context Engineering","text":"<p>The transcript is Claude's memory - a JSONL file containing the entire conversation history. It's mutable: edit it, and you edit what Claude remembers.</p> <p>\"Claude only knows what's in the transcript. Modify it, and Claude's memory changes.\"</p>"},{"location":"tutorial/transcript/#quick-start","title":"Quick Start","text":"<pre><code>from fasthooks import HookApp\nfrom fasthooks.depends import Transcript\n\napp = HookApp()\n\n@app.on_prompt()\ndef inject_context(event, transcript: Transcript):\n    \"\"\"Add context before Claude responds.\"\"\"\n    from fasthooks.transcript import UserMessage\n\n    # Create a \"memory\" that user mentioned type hints\n    reminder = UserMessage.create(\n        \"Remember: always use type hints in this project\",\n        context=transcript.entries[-1]  # Copy metadata from last entry\n    )\n    transcript.insert(0, reminder)  # Insert at start\n    transcript.save()\n</code></pre>"},{"location":"tutorial/transcript/#the-transcript-model","title":"The Transcript Model","text":""},{"location":"tutorial/transcript/#loading-a-transcript","title":"Loading a Transcript","text":"<pre><code>from fasthooks.transcript import Transcript\n\n# From path\nt = Transcript(\"/path/to/transcript.jsonl\")\n\n# In hooks - auto-injected via DI\n@app.pre_tool(\"Bash\")\ndef check(event, transcript: Transcript):\n    print(f\"Entries: {len(transcript.entries)}\")\n</code></pre>"},{"location":"tutorial/transcript/#entry-types","title":"Entry Types","text":"Type Description <code>UserMessage</code> User input or tool results <code>AssistantMessage</code> Claude's responses <code>SystemEntry</code> System events (compaction, hooks) <code>FileHistorySnapshot</code> File backup for undo <pre><code>from fasthooks.transcript import UserMessage, AssistantMessage\n\nfor entry in transcript.entries:\n    if isinstance(entry, UserMessage):\n        print(f\"User: {entry.text[:50]}...\")\n    elif isinstance(entry, AssistantMessage):\n        print(f\"Claude: {entry.text[:50]}...\")\n        if entry.has_tool_use:\n            for tu in entry.tool_uses:\n                print(f\"  Tool: {tu.name}\")\n</code></pre>"},{"location":"tutorial/transcript/#content-blocks","title":"Content Blocks","text":"<p>Assistant messages contain content blocks:</p> <pre><code>for entry in transcript.assistant_messages:\n    # Text content\n    print(entry.text)\n\n    # Thinking (extended thinking mode)\n    if entry.thinking:\n        print(f\"Thinking: {entry.thinking[:100]}...\")\n\n    # Tool uses\n    for tu in entry.tool_uses:\n        print(f\"Tool: {tu.name}, Input: {tu.input}\")\n\n        # Get the result\n        if tu.result:\n            print(f\"Result: {tu.result.content[:100]}...\")\n            if tu.result.is_error:\n                print(\"  (error)\")\n</code></pre>"},{"location":"tutorial/transcript/#querying","title":"Querying","text":""},{"location":"tutorial/transcript/#pre-built-views","title":"Pre-built Views","text":"<pre><code># Messages by type\ntranscript.user_messages      # List[UserMessage]\ntranscript.assistant_messages # List[AssistantMessage]\n\n# Tool interactions\ntranscript.tool_uses    # All ToolUseBlocks\ntranscript.tool_results # All ToolResultBlocks\ntranscript.errors       # Tool results where is_error=True\n\n# Groupings\ntranscript.turns        # List[Turn] - grouped by requestId\n</code></pre>"},{"location":"tutorial/transcript/#fluent-query-api","title":"Fluent Query API","text":"<p>Inspired by Django ORM and Tidyverse:</p> <pre><code># Type shortcuts\ntranscript.query().users().all()\ntranscript.query().assistants().with_tools().all()\n\n# Filtering\ntranscript.query().filter(type=\"assistant\").all()\ntranscript.query().filter(text__contains=\"error\").all()\ntranscript.query().where(lambda e: e.has_tool_use).all()\n\n# Lookups\ntranscript.query().filter(timestamp__gt=datetime(2024, 1, 1)).all()\ntranscript.query().filter(type__in=[\"user\", \"assistant\"]).all()\n\n# Ordering\ntranscript.query().order_by(\"-timestamp\").limit(10).all()\n\n# Terminals\ntranscript.query().assistants().count()     # int\ntranscript.query().with_errors().exists()   # bool\ntranscript.query().filter(uuid=\"abc\").one() # single entry or ValueError\n</code></pre>"},{"location":"tutorial/transcript/#time-based-queries","title":"Time-based Queries","text":"<pre><code>from datetime import datetime\n\n# Entries since timestamp\ntranscript.query().since(datetime(2024, 1, 1)).all()\ntranscript.query().since(\"2024-01-01T00:00:00\").all()\n\n# Entries until timestamp\ntranscript.query().until(datetime.now()).all()\n</code></pre>"},{"location":"tutorial/transcript/#creating-entries","title":"Creating Entries","text":""},{"location":"tutorial/transcript/#factory-methods","title":"Factory Methods","text":"<pre><code>from fasthooks.transcript import UserMessage, AssistantMessage\n\n# Create user message\nmsg = UserMessage.create(\n    \"Remember to use Python 3.11+\",\n    parent=transcript.entries[-1],  # Sets parent_uuid\n    context=transcript.entries[0],  # Copies session_id, cwd, etc.\n)\n\n# Create assistant message\nresponse = AssistantMessage.create(\n    \"Understood, I'll use Python 3.11+ features.\",\n    parent=msg,\n    model=\"synthetic\",  # Default\n)\n</code></pre> <p>Created entries are marked with <code>is_synthetic=True</code>.</p>"},{"location":"tutorial/transcript/#injecting-tool-results","title":"Injecting Tool Results","text":"<p>For faking tool executions:</p> <pre><code>from fasthooks.transcript import inject_tool_result\n\n# Claude \"remembers\" running this command\nassistant, user = inject_tool_result(\n    transcript,\n    tool_name=\"Read\",\n    tool_input={\"file_path\": \"/project/config.json\"},\n    result='{\"debug\": true, \"log_level\": \"INFO\"}',\n)\n\n# With error\ninject_tool_result(\n    transcript,\n    \"Bash\",\n    {\"command\": \"rm -rf /\"},\n    \"Permission denied\",\n    is_error=True,\n)\n\n# At specific position\ninject_tool_result(transcript, \"Bash\", {...}, \"output\", position=\"start\")\ninject_tool_result(transcript, \"Bash\", {...}, \"output\", position=5)\n</code></pre>"},{"location":"tutorial/transcript/#crud-operations","title":"CRUD Operations","text":""},{"location":"tutorial/transcript/#insert","title":"Insert","text":"<pre><code># At position (rewires parent_uuid chain)\ntranscript.insert(0, entry)      # At start\ntranscript.insert(5, entry)      # At index 5\n\n# At end\ntranscript.append(entry)\n</code></pre>"},{"location":"tutorial/transcript/#remove","title":"Remove","text":"<pre><code># Remove single entry, relink children\ntranscript.remove(entry, relink=True)  # Default\n\n# Remove entry and all descendants\nremoved = transcript.remove_tree(entry)\nprint(f\"Removed {len(removed)} entries\")\n</code></pre>"},{"location":"tutorial/transcript/#replace","title":"Replace","text":"<pre><code># Swap entry, preserve position in chain\ntranscript.replace(old_entry, new_entry)\n</code></pre>"},{"location":"tutorial/transcript/#save","title":"Save","text":"<pre><code># Atomic write (temp file + rename)\ntranscript.save()\n\n# Batch operations with auto-commit/rollback\nwith transcript.batch():\n    transcript.remove(entry1)\n    transcript.insert(0, new_entry)\n    # Auto-saves on success, rollback on exception\n</code></pre>"},{"location":"tutorial/transcript/#statistics","title":"Statistics","text":"<pre><code>stats = transcript.stats\n\n# Token usage\nprint(f\"Input: {stats.input_tokens}\")\nprint(f\"Output: {stats.output_tokens}\")\nprint(f\"Cache read: {stats.cache_read_tokens}\")\n\n# Tool calls\nprint(f\"Tools: {stats.tool_calls}\")  # {\"Bash\": 5, \"Read\": 3}\nprint(f\"Errors: {stats.error_count}\")\n\n# Session info\nprint(f\"Messages: {stats.message_count}\")\nprint(f\"Turns: {stats.turn_count}\")\nprint(f\"Duration: {stats.duration_seconds}s\")\n</code></pre>"},{"location":"tutorial/transcript/#exporting","title":"Exporting","text":""},{"location":"tutorial/transcript/#to-string","title":"To String","text":"<pre><code># Markdown - nice for reading\nmd = transcript.to_markdown()\nmd = transcript.to_markdown(\n    include_thinking=True,      # Show thinking blocks (collapsed)\n    include_tool_input=True,    # Show tool input JSON\n    max_content_length=500,     # Truncate long content\n)\n\n# HTML - for sharing\nhtml = transcript.to_html(title=\"Debug Session\")\n\n# JSON - for processing\njson_str = transcript.to_json(indent=2)\n\n# JSONL - original format\njsonl = transcript.to_jsonl()\n</code></pre>"},{"location":"tutorial/transcript/#to-file","title":"To File","text":"<pre><code>transcript.to_file(\"session.md\")\ntranscript.to_file(\"session.html\", format=\"html\")\ntranscript.to_file(\"session.json\", format=\"json\")\n</code></pre>"},{"location":"tutorial/transcript/#use-cases","title":"Use Cases","text":""},{"location":"tutorial/transcript/#inject-project-context","title":"Inject Project Context","text":"<pre><code>@app.on_session_start()\ndef add_context(event, transcript: Transcript):\n    \"\"\"Inject project guidelines at session start.\"\"\"\n    reminder = UserMessage.create(\n        \"Project rules: Use Black formatting, type hints required, pytest for tests\",\n        context=transcript.entries[0] if transcript.entries else None,\n    )\n    transcript.insert(0, reminder)\n    transcript.save()\n</code></pre>"},{"location":"tutorial/transcript/#redact-sensitive-data","title":"Redact Sensitive Data","text":"<pre><code>@app.on_stop()\ndef redact_secrets(event, transcript: Transcript):\n    \"\"\"Remove API keys from transcript.\"\"\"\n    import re\n    pattern = re.compile(r'sk-[a-zA-Z0-9]{32,}')\n\n    with transcript.batch():\n        for result in transcript.tool_results:\n            if pattern.search(result.content):\n                result.content = pattern.sub('[REDACTED]', result.content)\n</code></pre>"},{"location":"tutorial/transcript/#summarize-large-outputs","title":"Summarize Large Outputs","text":"<pre><code>@app.post_tool(\"Read\")\ndef summarize_large_files(event, transcript: Transcript):\n    \"\"\"Replace large file contents with summary.\"\"\"\n    if len(event.content or \"\") &gt; 5000:\n        for result in transcript.tool_results:\n            if result.tool_use_id == event.tool_use_id:\n                lines = result.content.count('\\n')\n                result.content = f\"[File: {event.file_path}, {lines} lines]\"\n        transcript.save()\n</code></pre>"},{"location":"tutorial/transcript/#analyze-session","title":"Analyze Session","text":"<pre><code>@app.on_stop()\ndef analyze(event, transcript: Transcript):\n    \"\"\"Log session analytics.\"\"\"\n    stats = transcript.stats\n\n    # Check for issues\n    if stats.error_count &gt; 5:\n        print(f\"Warning: {stats.error_count} errors in session\")\n\n    # Export for review\n    if stats.output_tokens &gt; 50000:\n        transcript.to_file(f\"/tmp/large_session_{stats.slug}.md\")\n</code></pre>"},{"location":"tutorial/transcript/#fake-tool-results-for-context","title":"Fake Tool Results for Context","text":"<pre><code>@app.on_prompt()\ndef inject_fake_config(event, transcript: Transcript):\n    \"\"\"Make Claude 'remember' reading a config file.\"\"\"\n    inject_tool_result(\n        transcript,\n        \"Read\",\n        {\"file_path\": \"/project/.claude-config\"},\n        \"prefer_typescript=true\\nmax_file_size=1000\",\n        position=\"start\",\n    )\n    transcript.save()\n</code></pre>"},{"location":"tutorial/transcript/#advanced-archived-entries","title":"Advanced: Archived Entries","text":"<p>Entries before the last context compaction are in <code>transcript.archived</code>:</p> <pre><code># Current context window only (default)\ntranscript.entries\n\n# Pre-compaction entries\ntranscript.archived\n\n# Both\ntranscript.all_entries\n\n# Query with archived\ntranscript.query(include_archived=True).count()\n</code></pre>"},{"location":"tutorial/transcript/#when-do-changes-take-effect","title":"When Do Changes Take Effect?","text":"Hook When Changes Apply <code>on_session_start</code> First response <code>on_prompt</code> Current response <code>pre_tool</code> Next turn (current continues) <code>post_tool</code> Next turn <code>on_stop</code> Next user turn <p>To affect the current response, modify in <code>on_prompt</code> before Claude starts.</p>"}]}